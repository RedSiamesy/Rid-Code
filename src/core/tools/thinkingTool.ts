import { Task } from "../task/Task"
import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag, ToolResponse } from "../../shared/tools"
import { formatResponse } from "../prompts/responses"
import { t } from "../../i18n"
import { ApiHandler, buildApiHandler } from "../../api"
import { ApiMessage } from "../../core/task-persistence/apiMessages"
import { getMessagesSinceLastSummary } from "../condense"
import { ApiStream } from "../../api/transform/stream"

export async function thinkingTool(
	task: Task,
	block: ToolUse,
	askApproval: AskApproval,
	handleError: HandleError,
	pushToolResult: PushToolResult,
	removeClosingTag: RemoveClosingTag,
) {
	try {
		if (block.partial) {
			return
		}

		// 获取 thinking tool 配置并构建 API handler
		const state = await task.providerRef.deref()?.getState()
		const thinkingToolApiConfigId = state?.thinkingToolApiConfigId
		const listApiConfigMeta = state?.listApiConfigMeta

		// 确定要使用的 API handler
		let thinkingApiHandler: ApiHandler | undefined
		if (thinkingToolApiConfigId && thinkingToolApiConfigId !== "default" && listApiConfigMeta && Array.isArray(listApiConfigMeta)) {
			// 通过 ID 查找匹配的配置（仅在不是default时）
			const matchingConfig = listApiConfigMeta.find((config) => config.id === thinkingToolApiConfigId)
			if (matchingConfig) {
				const profile = await task.providerRef.deref()?.providerSettingsManager.getProfile({
					id: thinkingToolApiConfigId,
				})
				// 确保_profile 和 apiProvider 存在再尝试构建 handler
				if (profile && profile.apiProvider) {
					thinkingApiHandler = buildApiHandler(profile)
				}
			}
		}

		// 如果没有配置专门的 thinking API handler（包括选择了default），使用主要的 API handler 作为后备
		const apiHandlerToUse = thinkingApiHandler || task.api

		const stream = await performAnalysis(task, apiHandlerToUse, true)
		let analysisResult = ""
		let analysisreasoning = "<thinking>"
		await task.say("text", " ")
		for await (const chunk of stream) {
			if (chunk.type === "reasoning") {
				analysisreasoning += chunk.text
				await task.say("reasoning", analysisreasoning, undefined, true)
			}
			if (chunk.type === "text" && chunk.text.trim()) {
				if (analysisResult === "") {
					analysisreasoning += "</thinking>\n\n"
				}
				analysisreasoning += chunk.text
				analysisResult += chunk.text
				await task.say("reasoning", analysisreasoning, undefined, true)
			}
		}
		await task.say("text", " ")
		pushToolResult("The following is an analysis and set of suggestions regarding the current task process, generated by the thinking_tool based on the current context:\n"+analysisResult)

	} catch (error) {
		const errorMessage = `Thinking Tool 执行失败: ${error instanceof Error ? error.message : String(error)}`
		await handleError("thinking_tool", error)
		pushToolResult(formatResponse.toolError(errorMessage))
	}
}

async function performAnalysis(
	task: Task,
	apiHandler?: ApiHandler,
	review? : boolean,
	feedback?: Anthropic.Messages.ContentBlockParam[]
): Promise<ApiStream> {
	// 如果没有可用的 API handler，返回占位符消息
	if (!apiHandler) {
		throw new Error("没有可用的 API 配置来执行思考工具。请检查设置。")
	}

	try {
		// 获取当前任务的上下文信息
		const taskContext = await getCurrentTaskContext(task, feedback)

		const review_block = `- 遗漏的要点： (如果前面的工作中，确认完全没有任何遗漏，或还未进行过任何工作，可以没有这部分)
	1. 未能深入分析xxx相关的前端/后端逻辑
	2. 未发现yyy如何设置···
	3. ...
	...
`

		// 准备发送给 API 的完整消息
		const systemPrompt = `
# YOUR Tone and style
You should be concise, direct, and to the point.
You MUST answer concisely with fewer than 4 lines (not including tool use or code generation), unless user asks for detail.
IMPORTANT: You should minimize output tokens as much as possible while maintaining helpfulness, quality, and accuracy. Only address the specific task at hand, avoiding tangential information unless absolutely critical for completing the request. If you can answer in 1-3 sentences or a short paragraph, please do.
IMPORTANT: You should NOT answer with unnecessary preamble or postamble (such as explaining your code or summarizing your action), unless the user asks you to.
Do not add additional code explanation summary unless requested by the user. After working on a file, just stop, rather than providing an explanation of what you did.
Answer the user's question directly, avoiding any elaboration, explanation, introduction, conclusion, or excessive details. You MUST avoid text before/after your response, such as \"The answer is <answer>.\", \"Here is the content of the file...\" or \"Based on the information provided, the answer is...\" or \"Here is what I will do next...\" or "太好了..." or "有趣...".

Remember that your output will be displayed on a command line interface. Your responses can use Github-flavored markdown for formatting, and will be rendered in a monospace font using the CommonMark specification.
Output text to communicate with the user; all text you output outside of tool use is displayed to the user. Only use tools to complete tasks. Never use tools like Bash or code comments as means to communicate with the user during the session.
Only use emojis if the user explicitly requests it. Avoid using emojis in all communication unless asked.
IMPORTANT: Keep your responses short, since they will be displayed on a command line interface.

你是一个专业的代码助手和系统分析师。现在，有一个主agent在前台进行运作。
You are a professional code assistant and system analyst. Now, a main agent is operating in the foreground.

请基于已有的上下文对话信息和工作流程，分析以下内容：
Please analyze the following two points based on the main agent's workflow and the context dialogue information he receives:

- 关注用户当前的主要任务
${review ? "- 在主agent已经完成的工作中，是否存在遗漏和欠缺考虑的要点 (Review for omissions or oversights in the main agent's completed work)" : ""}
- 基于已经已收集到的信息，结合当前的阶段性任务，分析当前阶段的工作要点 (Analyze key priorities for the current stage, based on collected information and immediate objectives)
- 当前阶段完成后，后续主agent的发展方向和规划 (Outline the future direction and roadmap for the main agent after the current stage is complete)


你的回答只需要包含上述几点，不要包含任何对主agent已完成工作的分析、总结和复述，直接列出${review ? "“遗漏和欠缺考虑的要点”、" : ""}“当前阶段的工作重心”和“针对当前任务的后续规划和发展方向”。简短但完整精确地回答问题。
Your response should only contain the points listed above. Do not include any analysis, summary, or restatement of the main agent's completed work. Directly list ${review ? '"Omissions and Oversights", ' : ''}"Key Priorities for the Current Stage", and "Future Plan and Roadmap for the task". Keep your answer concise, yet complete and precise.

Here are some examples to demonstrate appropriate verbosity:
<example>
user:
...(some context)...
assistant(your answer):
${review ? review_block : ""}- 当前阶段的工作重心：(如果当前阶段性任务已经确认完成，可以没有这部分)
	1. 在项目中搜索aaa...(行为)，以...(这样做的目的)
	2. 分析bbb的实现方式...(行为)，目的是为了...(这样做的目的)
	3. ...
	...
- 针对当前任务的后续行为和发展方向建议：(如果整个任务已经确认完成，不需要后续动作，可以没有这部分)
	1. 后续的可选方案如：
		a.....;
		b.....;
		c.....;
		...(如果提供方案，可以简洁快速地描述方案的思路和大体框架，不要写详细内容)
	2. 在项目中搜索cccc...(行为)，用于...(这样做的目的)
	3. 分析dddd的实现方式...(行为)，以...(这样做的目的)
	4. ...
	...
</example>

主agent可能可以使用的工具包括:
- "update_todo_list" todolist设置工具
- "glob/grep/codebase_search" 等内容搜索工具
- "list_code_definition_names" 等语法树分析工具
- "read_file/list_files" 等文件系统工具
- "apply_diff/insert_content/write_to_file/search_and_replace" 等编辑工具
- "new_task" 子智能体创建工具
- "execute_command" bash命令应用工具
- "web_search/url_fetch" 等网络工具

以下是主agent的工作规则和要求：
<main_agent_rules>
- For simple greetings or very simple questions, don't complicate them; answer directly and as briefly as possible
- You should proactively use the 'new_task' tool with specialized agents when the task at hand matches the agent's description. For example, when doing file search and are currently not in ask mode, prefer to use the 'new_task' tool with 'ask' mode to start a "Analysis" subtask.
- When WebFetch returns a message about a redirect to a different host, you should immediately make a new WebFetch request with the redirect URL provided in the response. 
- When executing commands, if you don't see the expected output, use the ask_followup_question tool to request the user to copy and paste it back to you.
- For analysis: Start broad and narrow down. Use multiple search strategies if the first doesn't yield results.
- Don't be stingy with search attempts; **use various keywords or matching patterns from multiple angles to conduct a broad search**.
- Be thorough: When you use a search tool, check multiple locations, consider different naming conventions, look for related files.
- For key content or logic encountered during the process of understanding source code, you MUST use the search tools (like glob/grep) to perform comprehensive verification searches in a big scope to determine their scope of influence.
- **CRITICAL: For ANY exploration of code you haven't examined yet in this conversation, you MUST use the \`codebase_search\` tool FIRST before using grep/glob or other file exploration tools.** This requirement applies throughout the entire conversation, not just when starting a task. The codebase_search tool uses semantic search to find relevant code based on meaning, not just keywords, making it much more effective for understanding how features are implemented. Even if you've already explored some parts of the codebase, any new area or functionality you need to understand requires using codebase_search first. The “codebase_search” can help you start from an unknown field but cannot help you find all clues, as it will lose some more accurate and detailed information. Therefore, you **SHOULD NOT** rely entirely on “codebase_search” and should use more explicitly controllable tools like \`grep\`, \`glob\`, \`read_file\`, \`list_code_definition_names\` after obtaining the clue. Implement the solution using all tools available to you."
- After finding contextual information related to the issue, you should still perform redundant searches using the additional key information and reflect to **ENSURE that no content related to the task is missed**.
- IMPORTANT: If you want to reference code in a file, you MUST use a markdown-formatted link pointing to the location of the source code, rather than outputting it as texts or code blocks. It allows you to direct the user to easily navigate to the source code location.
- For all file paths, use markdown-formatted links to point to the source files.
- Think harder: You should conduct periodic reviews and reflections at appropriate times, asking yourself if you have missed any clues or key points.
- For key content or logic encountered during the process of understanding source code, you MUST use the search tools (like glob/grep) to perform comprehensive verification searches in a big scope to determine their scope of influence.
- NEVER update the todo list multiple times in one message
</main_agent_rules>


====

YOUR RULES

如果最新的对话是用户提出的一个新的任务，你应该将工作重心放在“根据主agent已有线索和任务详情，分析规划新任务的方向和要点”上。
If the latest conversation is a new task proposed by the user, you should focus on analyzing and planning the direction and key points of the new task based on existing clues and task details.

${review ? "注意：你发现和提出的遗漏和建议需要符合解决当前问题的一般常理和规则，不能脱离实际 \nNote: The omissions you discover and propose should align with the general principles and rules for resolving current issues and cannot be detached from reality":""}

注意：你的思考和回答应该围绕用户当前的主要任务（任务来源于用户的<task></task>标签或<feedback></feedback>或<answer></answer>中）
Note: Your thinking and answers should revolve around the user's current main task (the task come from the user <task></task> tag or <feedback></feedback> tag or <answer></answer> tag).

注意：如果当前只是问候或者简单任务，请勿过度思考，不需要上述几个板块，你应该让主agent以最简单的形式进行直接回复
Note: If it's just a greeting or a simple task, don't overthink it, you don't need the above sections. You should let the main agent reply in the simplest form directly

注意：使用历史对话中的常用语言（en，zh-CN或其他语言）进行思考和回答。
Note: Think and respond in the primary language used in the conversation history (e.g., en, zh-CN, or other languages).

**注意：你没有任何调用工具的能力，不要尝试调用历史对话中所展示的工具完成具体的操作！你的任务是协助主agent对任务进行规划和分析！**
**IMPORTANT: You have NO tool-calling capabilities. DO NOT attempt to use any tools shown in the conversation history to perform actions. Your sole mission is to identify what the main agent has missed and to provide high-level directional guidance!**

你的这些指示将应用于 可以调用各种工具的主agent智能体 进行工作。
The guidance you provide will be used by another agent, one that is capable of calling various tools to execute the work.

如果主agent的工作滴水不漏且完成了任务，可以简要回复，说明任务已经圆满完成。
`

		// 构建 API 消息
		const apiMessages: ApiMessage[] = [
			{ role: "user" as const, content: `主agent的工作流程：\n${taskContext}\n\n请分析主agent工作过程中遗漏和欠缺的要点以及后续规划和发展方向。` }
		]

		// 调用 API 进行分析
		const stream = await apiHandler.createMessage(
			systemPrompt,
			apiMessages
		)

		return stream

	} catch (error) {
		throw new Error("思考工具分析失败: " + (error instanceof Error ? error.message : String(error)))
	}
}

async function getCurrentTaskContext(task: Task, feedback?: Anthropic.Messages.ContentBlockParam[]): Promise<string> {
	try {
		return JSON.stringify([...getMessagesSinceLastSummary(task.apiConversationHistory), ...(feedback ? [{content: feedback, role: 'user'}]:[])])
	} catch (error) {
		return `获取任务上下文时出现错误: ${error instanceof Error ? error.message : String(error)}`
	}
}

import { Anthropic } from "@anthropic-ai/sdk"

export async function userExecuteThinking(
	task: Task,
	feedback: Anthropic.Messages.ContentBlockParam[]
): Promise<string | undefined> {
	try {
		// 获取 thinking tool 配置并构建 API handler
		const state = await task.providerRef.deref()?.getState()
		const thinkingToolApiConfigId = state?.thinkingToolApiConfigId
		const listApiConfigMeta = state?.listApiConfigMeta

		// 确定要使用的 API handler
		let thinkingApiHandler: ApiHandler | undefined
		if (thinkingToolApiConfigId && thinkingToolApiConfigId !== "default" && listApiConfigMeta && Array.isArray(listApiConfigMeta)) {
			// 通过 ID 查找匹配的配置（仅在不是default时）
			const matchingConfig = listApiConfigMeta.find((config) => config.id === thinkingToolApiConfigId)
			if (matchingConfig) {
				const profile = await task.providerRef.deref()?.providerSettingsManager.getProfile({
					id: thinkingToolApiConfigId,
				})
				// 确保_profile 和 apiProvider 存在再尝试构建 handler
				if (profile && profile.apiProvider) {
					thinkingApiHandler = buildApiHandler(profile)
				}
			}
		}

		// 如果没有配置专门的 thinking API handler（包括选择了default），使用主要的 API handler 作为后备
		const apiHandlerToUse = thinkingApiHandler || task.api

		const stream = await performAnalysis(task, apiHandlerToUse, false, feedback)
		let analysisResult = ""
		let analysisreasoning = ""
		await task.say("text", " ")
		for await (const chunk of stream) {
			if (chunk.type === "reasoning") {
				if (analysisreasoning === "") {
					analysisreasoning += "<thinking>\n"
				}
				task.postprocess._reasoning += chunk.text
				analysisreasoning += chunk.text
				await task.say("reasoning", analysisreasoning, undefined, true)
			}
			if (chunk.type === "text" && chunk.text.trim()) {
				if (analysisResult === "" && analysisreasoning !=="") {
					analysisreasoning += "\n</thinking>\n\n"
				}
				analysisreasoning += chunk.text
				analysisResult += chunk.text
				await task.say("reasoning", analysisreasoning, undefined, true)
			}
		}
		await task.say("text", " ")
		return "Thinking tool respond:\n"+analysisResult

	} catch (error) {
		return undefined
	}
}