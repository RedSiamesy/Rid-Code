diff --git a/src/core/prompts/sections/system-info.ts b/src/core/prompts/sections/system-info.ts
index 8adc90a1..db801d65 100644
--- a/src/core/prompts/sections/system-info.ts
+++ b/src/core/prompts/sections/system-info.ts
@@ -11,9 +11,9 @@ SYSTEM INFORMATION
 Operating System: ${osName()}
 Default Shell: ${getShell()}
 Home Directory: ${os.homedir().toPosix()}
-Current Workspace Directory: ${cwd.toPosix()}
+Current Workspace Directory: ${cwd.toPosix()}`
 
-The Current Workspace Directory is the active VS Code project directory, and is therefore the default directory for all tool operations. New terminals will be created in the current workspace directory, however if you change directories in a terminal it will then have a different working directory; changing directories in a terminal does not modify the workspace directory, because you do not have access to change the workspace directory. When the user initially gives you a task, a recursive list of all filepaths in the current workspace directory ('/test/path') will be included in environment_details. This provides an overview of the project's file structure, offering key insights into the project from directory/file names (how developers conceptualize and organize their code) and file extensions (the language used). This can also guide decision-making on which files to explore further. If you need to further explore directories such as outside the current workspace directory, you can use the list_files tool. If you pass 'true' for the recursive parameter, it will list files recursively. Otherwise, it will list files at the top level, which is better suited for generic directories where you don't necessarily need the nested structure, like the Desktop.`
+// The Current Workspace Directory is the active VS Code project directory, and is therefore the default directory for all tool operations. New terminals will be created in the current workspace directory, however if you change directories in a terminal it will then have a different working directory; changing directories in a terminal does not modify the workspace directory, because you do not have access to change the workspace directory. When the user initially gives you a task, a recursive list of all filepaths in the current workspace directory ('/test/path') will be included in environment_details. This provides an overview of the project's file structure, offering key insights into the project from directory/file names (how developers conceptualize and organize their code) and file extensions (the language used). This can also guide decision-making on which files to explore further. If you need to further explore directories such as outside the current workspace directory, you can use the list_files tool. If you pass 'true' for the recursive parameter, it will list files recursively. Otherwise, it will list files at the top level, which is better suited for generic directories where you don't necessarily need the nested structure, like the Desktop.`
 
 	return details
 }
diff --git a/src/core/prompts/sections/tool-use-guidelines.ts b/src/core/prompts/sections/tool-use-guidelines.ts
index a526bbc7..2c068e45 100644
--- a/src/core/prompts/sections/tool-use-guidelines.ts
+++ b/src/core/prompts/sections/tool-use-guidelines.ts
@@ -15,6 +15,7 @@ export function getToolUseGuidelinesSection(codeIndexManager?: CodeIndexManager)
 	guidelinesList.push(
 		`${itemNumber++}. In <thinking> tags, assess what information you already have and what information you need to proceed with the task.`,
 	)
+	guidelinesList.push(`${itemNumber++}. Formulate your tool use using the XML format specified for each tool.`)
 
 	// Conditional codebase search guideline
 	if (isCodebaseSearchAvailable) {
@@ -22,7 +23,7 @@ export function getToolUseGuidelinesSection(codeIndexManager?: CodeIndexManager)
 			`${itemNumber++}. **CRITICAL: For ANY exploration of code you haven't examined yet in this conversation, you MUST use the \`codebase_search\` tool FIRST before any other search or file exploration tools.** This applies throughout the entire conversation, not just at the beginning. The codebase_search tool uses semantic search to find relevant code based on meaning rather than just keywords, making it far more effective than regex-based search_files for understanding implementations. Even if you've already explored some code, any new area of exploration requires codebase_search first.`,
 		)
 		guidelinesList.push(
-			`${itemNumber++}. Choose the most appropriate tool based on the task and the tool descriptions provided. After using codebase_search for initial exploration of any new code area, you may then use more specific tools like search_files (for regex patterns), list_files, or read_file for detailed examination. For example, using the list_files tool is more effective than running a command like \`ls\` in the terminal. It's critical that you think about each available tool and use the one that best fits the current step in the task.`,
+			`${itemNumber++}. Choose the most appropriate tool based on the task and the tool descriptions provided. The “codebase_search” can help you start from an unknown field but cannot help you find all clues, as it will lose some more accurate and detailed information. Therefore, you should not rely entirely on “codebase_search” and should use more explicitly controllable tools like search_files (for regex patterns), read_file, list_code_definition_names. It's critical that you think about each available tool and use the one that best fits the current step in the task. For example using the list_files tool is more effective than running a command like \`ls\` in the terminal. `,
 		)
 	} else {
 		guidelinesList.push(
@@ -34,7 +35,6 @@ export function getToolUseGuidelinesSection(codeIndexManager?: CodeIndexManager)
 	guidelinesList.push(
 		`${itemNumber++}. If multiple actions are needed, use one tool at a time per message to accomplish the task iteratively, with each tool use being informed by the result of the previous tool use. Do not assume the outcome of any tool use. Each step must be informed by the previous step's result.`,
 	)
-	guidelinesList.push(`${itemNumber++}. Formulate your tool use using the XML format specified for each tool.`)
 	guidelinesList.push(`${itemNumber++}. After each tool use, the user will respond with the result of that tool use. This result will provide you with the necessary information to continue your task or make further decisions. This response may include:
   - Information about whether the tool succeeded or failed, along with any reasons for failure.
   - Linter errors that may have arisen due to the changes you made, which you'll need to address.
@@ -56,4 +56,4 @@ It is crucial to proceed step-by-step, waiting for the user's message after each
 4. Ensure that each action builds correctly on the previous ones.
 
 By waiting for and carefully considering the user's response after each tool use, you can react accordingly and make informed decisions about how to proceed with the task. This iterative process helps ensure the overall success and accuracy of your work.`
-}
+}
\ No newline at end of file
diff --git a/src/core/prompts/sections/tool-use.ts b/src/core/prompts/sections/tool-use.ts
index ea27e591..0effaa1c 100644
--- a/src/core/prompts/sections/tool-use.ts
+++ b/src/core/prompts/sections/tool-use.ts
@@ -1,9 +1,11 @@
-export function getSharedToolUseSection(): string {
+export function getSharedToolUseSection(allowedMultiCall?: boolean): string {
+	const allowedMultiCallEnabled = allowedMultiCall ?? false
 	return `====
 
 TOOL USE
 
-You have access to a set of tools that are executed upon the user's approval. You can use one tool per message, and will receive the result of that tool use in the user's response. You use tools step-by-step to accomplish a given task, with each tool use informed by the result of the previous tool use.
+${ allowedMultiCallEnabled ? "You have access to a set of tools that are executed upon the user's approval. You can use multiple tools per message, and will receive the result of that tool use in the user's response. "
+:"You have access to a set of tools that are executed upon the user's approval. You can use one tool per message, and will receive the result of that tool use in the user's response. You use tools step-by-step to accomplish a given task, with each tool use informed by the result of the previous tool use."}
 
 # Tool Use Formatting
 
@@ -15,7 +17,7 @@ Tool uses are formatted using XML-style tags. The tool name itself becomes the X
 ...
 </actual_tool_name>
 
-For example, to use the new_task tool:
+For example, to use the sub agent tool:
 
 <new_task>
 <mode>code</mode>
diff --git a/src/core/prompts/system.ts b/src/core/prompts/system.ts
index cbe91903..e8e3c237 100644
--- a/src/core/prompts/system.ts
+++ b/src/core/prompts/system.ts
@@ -60,7 +60,6 @@ async function generatePrompt(
 	rooIgnoreInstructions?: string,
 	partialReadsEnabled?: boolean,
 	settings?: SystemPromptSettings,
-	todoList?: TodoItem[],
 ): Promise<string> {
 	if (!context) {
 		throw new Error("Extension context is required for generating system prompt")
@@ -81,17 +80,20 @@ async function generatePrompt(
 	const [modesSection, mcpServersSection] = await Promise.all([
 		getModesSection(context),
 		shouldIncludeMcp
-			? getMcpServersSection(mcpHub, effectiveDiffStrategy, enableMcpServerCreation)
+			? getMcpServersSection(mcpHub, effectiveDiffStrategy, enableMcpServerCreation, mode)
 			: Promise.resolve(""),
 	])
 
 	const codeIndexManager = CodeIndexManager.getInstance(context)
 
+	// Extract allowedMultiCall from experiments
+	const allowedMultiCall = experiments?.allowedMultiCall ?? false
+
 	const basePrompt = `${roleDefinition}
 
 ${markdownFormattingSection()}
 
-${getSharedToolUseSection()}
+${getSharedToolUseSection(allowedMultiCall)}
 
 ${getToolDescriptionsForMode(
 	mode,
@@ -107,19 +109,19 @@ ${getToolDescriptionsForMode(
 	settings,
 )}
 
-${getToolUseGuidelinesSection(codeIndexManager)}
+${true?"":getToolUseGuidelinesSection(codeIndexManager)}
 
 ${mcpServersSection}
 
-${getCapabilitiesSection(cwd, supportsComputerUse, shouldIncludeMcp ? mcpHub : undefined, effectiveDiffStrategy, codeIndexManager)}
+${true?"":getCapabilitiesSection(cwd, supportsComputerUse, shouldIncludeMcp ? mcpHub : undefined, effectiveDiffStrategy, codeIndexManager)}
 
 ${modesSection}
 
-${getRulesSection(cwd, supportsComputerUse, effectiveDiffStrategy, codeIndexManager)}
+${getRulesSection(cwd, supportsComputerUse, effectiveDiffStrategy, codeIndexManager, allowedMultiCall)}
 
 ${getSystemInfoSection(cwd)}
 
-${getObjectiveSection(codeIndexManager, experiments)}
+${true?"":getObjectiveSection(codeIndexManager, experiments)}
 
 ${await addCustomInstructions(baseInstructions, globalCustomInstructions || "", cwd, mode, {
 	language: language ?? formatLanguage(vscode.env.language),
@@ -148,7 +150,6 @@ export const SYSTEM_PROMPT = async (
 	rooIgnoreInstructions?: string,
 	partialReadsEnabled?: boolean,
 	settings?: SystemPromptSettings,
-	todoList?: TodoItem[],
 ): Promise<string> => {
 	if (!context) {
 		throw new Error("Extension context is required for generating system prompt")
@@ -170,6 +171,29 @@ export const SYSTEM_PROMPT = async (
 	// Get full mode config from custom modes or fall back to built-in modes
 	const currentMode = getModeBySlug(mode, customModes) || modes.find((m) => m.slug === mode) || modes[0]
 
+	if (mode === "native") {
+		const { roleDefinition, baseInstructions: baseInstructionsForFile } = getModeSelection(
+			mode,
+			promptComponent,
+			customModes,
+		)
+		const customInstructions = await addCustomInstructions(
+			baseInstructionsForFile,
+			globalCustomInstructions || "",
+			cwd,
+			mode,
+			{
+				language: language ?? formatLanguage(vscode.env.language),
+				rooIgnoreInstructions,
+				settings,
+			},
+		)
+
+		return `${roleDefinition}
+
+${customInstructions}`
+	}
+
 	// If a file-based custom system prompt exists, use it
 	if (fileCustomSystemPrompt) {
 		const { roleDefinition, baseInstructions: baseInstructionsForFile } = getModeSelection(
@@ -219,6 +243,5 @@ ${customInstructions}`
 		rooIgnoreInstructions,
 		partialReadsEnabled,
 		settings,
-		todoList,
 	)
 }
diff --git a/src/core/prompts/tools/attempt-completion.ts b/src/core/prompts/tools/attempt-completion.ts
index 904f9899..8d30af75 100644
--- a/src/core/prompts/tools/attempt-completion.ts
+++ b/src/core/prompts/tools/attempt-completion.ts
@@ -5,7 +5,7 @@ export function getAttemptCompletionDescription(args?: ToolArgs): string {
 Description: After each tool use, the user will respond with the result of that tool use, i.e. if it succeeded or failed, along with any reasons for failure. Once you've received the results of tool uses and can confirm that the task is complete, use this tool to present the result of your work to the user. The user may respond with feedback if they are not satisfied with the result, which you can use to make improvements and try again.
 IMPORTANT NOTE: This tool CANNOT be used until you've confirmed from the user that any previous tool uses were successful. Failure to do so will result in code corruption and system failure. Before using this tool, you must ask yourself in <thinking></thinking> tags if you've confirmed from the user that any previous tool uses were successful. If not, then DO NOT use this tool.
 Parameters:
-- result: (required) The result of the task. Formulate this result in a way that is final and does not require further input from the user. Don't end your result with questions or offers for further assistance.
+- result: (required) The result of the task. Formulate this result in a way that is final and does not require further input from the user. Don't end your result with questions or offers for further assistance. The content of <result> needs to describe in detail the conclusions and reports obtained, do not point to past conversations in <result>, and do not make users search for conclusions in historical conversations.
 Usage:
 <attempt_completion>
 <result>
diff --git a/src/core/prompts/tools/codebase-search.ts b/src/core/prompts/tools/codebase-search.ts
index 0fc8f68f..6e0ec175 100644
--- a/src/core/prompts/tools/codebase-search.ts
+++ b/src/core/prompts/tools/codebase-search.ts
@@ -1,9 +1,21 @@
 export function getCodebaseSearchDescription(): string {
 	return `## codebase_search
-Description: Find files most relevant to the search query.\nThis is a semantic search tool, so the query should ask for something semantically matching what is needed.\nIf it makes sense to only search in a particular directory, please specify it in the path parameter.\nUnless there is a clear reason to use your own search query, please just reuse the user's exact query with their wording.\nTheir exact wording/phrasing can often be helpful for the semantic search query. Keeping the same exact question format can also be helpful.\nIMPORTANT: Queries MUST be in English. Translate non-English queries before searching.
+### codebase_search (Search)
+Description: This tool performs a semantic search on a vector database of code and documentation. It retrieves the most relevant contextual information needed to answer user questions or resolve their requirements. The search is based on semantic meaning, not just keyword matching.
+
+When generating a 'query', follow these guidelines:
+
+- **Extract from Code:** If the conversation includes code snippets, extract key identifiers like class names, function names, method names, or variable names. These are often the most crucial elements to search for to understand the code's purpose and functionality.
+- **Infer from Context:** Go beyond the literal words in the conversation.
+    - **For Code-related Questions:** Infer potential function names, class names, or design patterns that might exist in the codebase to solve the user's problem.
+    - **For Documentation-related Questions:** Infer concepts, features, or "how-to" topics that would likely be covered in the documentation.
+- **Be Specific and Clear:**
+    - Formulate clear, descriptive queries. Avoid using overly short or ambiguous abbreviations.
+    - If the context strongly suggests the information is in a specific location, use the 'path' parameter to narrow the search.
+
 Parameters:
-- query: (required) The search query to find relevant code. You should reuse the user's exact query/most recent message with their wording unless there is a clear reason not to.
-- path: (optional) The path to the directory to search in relative to the current working directory. This parameter should only be a directory path, file paths are not supported. Defaults to the current working directory.
+- query: (required) A semantic query (or queries) to find relevant code or documentation. You can provide up to 4 queries, separated by " | ". Each query should be a meaningful phrase (at least 4 Chinese characters or 2 English words). Provide queries in both Chinese and English. 
+- path: (optional) The relative path to a file or directory to restrict the search. Defaults to the entire codebase.
 Usage:
 <codebase_search>
 <query>Your natural language query here</query>
@@ -15,5 +27,29 @@ Example: Searching for functions related to user authentication
 <query>User login and password hashing</query>
 <path>/path/to/directory</path>
 </codebase_search>
+
+
+### codebase_search (Summary)
+Description: Generates a detailed summary of a file or a directory's contents.
+
+This tool provides a high-level overview to help you quickly understand a codebase.
+- **If the path points to a file:** It returns a summary of the entire file, plus summaries of key sections (e.g., classes, functions) with their corresponding line numbers.
+- **If the path points to a directory:** It returns summaries for all supported files within that directory.
+
+Use this tool when you need to grasp the purpose and structure of a file or directory before diving into the details.
+
+**Important Note:** The tool is named 'codebase_search', but its function in this parameters rule is to **summarize**, not to search for a query.
+
+Parameters:
+- path: (optional) The relative path to the file or directory to be summarized. Defaults to the current working directory ('.').
+Usage:
+<codebase_search>
+<path>Path to the directory or file to summarize (optional)</path>
+</codebase_search>
+
+Example: Get a summary of a specific file or all supported files in '/path/to/directory_or_file'.
+<codebase_search>
+<path>/path/to/directory_or_file</path>
+</codebase_search>
 `
 }
diff --git a/src/core/prompts/tools/index.ts b/src/core/prompts/tools/index.ts
index 9f4af7f3..f5df6589 100644
--- a/src/core/prompts/tools/index.ts
+++ b/src/core/prompts/tools/index.ts
@@ -23,6 +23,8 @@ import { getSwitchModeDescription } from "./switch-mode"
 import { getNewTaskDescription } from "./new-task"
 import { getCodebaseSearchDescription } from "./codebase-search"
 import { getUpdateTodoListDescription } from "./update-todo-list"
+import { getWebSearchDescription } from "./web-search"
+import { getUrlFetchDescription } from "./url-fetch"
 import { CodeIndexManager } from "../../../services/code-index/manager"
 
 // Map of tool names to their description functions
@@ -47,6 +49,8 @@ const toolDescriptionMap: Record<string, (args: ToolArgs) => string | undefined>
 	apply_diff: (args) =>
 		args.diffStrategy ? args.diffStrategy.getToolDescription({ cwd: args.cwd, toolOptions: args.toolOptions }) : "",
 	update_todo_list: (args) => getUpdateTodoListDescription(args),
+	web_search: (args) => getWebSearchDescription(args),
+	url_fetch: (args) => getUrlFetchDescription(args),
 }
 
 export function getToolDescriptionsForMode(
diff --git a/src/core/prompts/tools/list-files.ts b/src/core/prompts/tools/list-files.ts
index 96c43ea4..15aa7956 100644
--- a/src/core/prompts/tools/list-files.ts
+++ b/src/core/prompts/tools/list-files.ts
@@ -16,5 +16,9 @@ Example: Requesting to list all files in the current directory
 <list_files>
 <path>.</path>
 <recursive>false</recursive>
-</list_files>`
+</list_files>
+
+
+Tips: You should use the \`list_files\` tool as LITTLE as possible, and instead use the \`search_files\` (Grep/Glob) tool, which is a powerful search tool that also has the function of matching specific filenames in a directory according to certain patterns.`
 }
+// IMPORTANT: Use \`list_files\` as LITTLE as possible, and instead use the \`Glob\` usage of \`search_files\` for more precise matching searches.
diff --git a/src/core/prompts/tools/new-task.ts b/src/core/prompts/tools/new-task.ts
index 7301b7b4..3c9d6355 100644
--- a/src/core/prompts/tools/new-task.ts
+++ b/src/core/prompts/tools/new-task.ts
@@ -1,12 +1,12 @@
 import { ToolArgs } from "./types"
 
 export function getNewTaskDescription(_args: ToolArgs): string {
-	return `## new_task
-Description: This will let you create a new task instance in the chosen mode using your provided message.
+	return `## sub_agent
+Description: This will let you create a sub agent instance in the chosen mode using your provided message.
 
 Parameters:
-- mode: (required) The slug of the mode to start the new task in (e.g., "code", "debug", "architect").
-- message: (required) The initial user message or instructions for this new task.
+- mode: (required) The slug of the mode to start the sub agent in (e.g., "code", "debug", "architect").
+- message: (required) The initial user message or instructions for this sub agent.
 
 Usage:
 <new_task>
diff --git a/src/core/prompts/tools/search-files.ts b/src/core/prompts/tools/search-files.ts
index fe8b0fc6..588debf7 100644
--- a/src/core/prompts/tools/search-files.ts
+++ b/src/core/prompts/tools/search-files.ts
@@ -1,23 +1,51 @@
 import { ToolArgs } from "./types"
 
 export function getSearchFilesDescription(args: ToolArgs): string {
-	return `## search_files
+	return `## search_files (Grep/Glob tool)
 Description: Request to perform a regex search across files in a specified directory, providing context-rich results. This tool searches for patterns or specific content across multiple files, displaying each match with encapsulating context.
+
+- ALWAYS use Grep for search tasks. NEVER invoke \`grep\` or \`rg\` as a Bash command. The Grep tool has been optimized for correct permissions and access.
+- Supports full regex syntax (e.g., "log.*Error", "function\s+\w+")
+- Filter files with glob parameter (e.g., "*.js", "**/*.tsx")
+- Output modes: "content" shows matching lines, "files_with_matches" shows only file paths (default)
+- Use Task tool for open-ended searches requiring multiple rounds
+- Pattern syntax: Uses ripgrep (not grep) - literal braces need escaping (use \`interface\\{\\}\` to find \`interface{}\` in Go code)
+
 Parameters:
 - path: (required) The path of the directory to search in (relative to the current workspace directory ${args.cwd}). This directory will be recursively searched.
 - regex: (required) The regular expression pattern to search for. Uses Rust regex syntax.
-- file_pattern: (optional) Glob pattern to filter files (e.g., '*.ts' for TypeScript files). If not provided, it will search all files (*).
+- file_pattern: (optional) Glob pattern to filter files, MUST conform to the syntax of the \`--glob\` parameter of the rg command (e.g., '*.ts' for TypeScript files, '*.{ts,js,json}' for TypeScript, JavaScript and JSON files). If not provided, it will search all files (*).
+- output_mode: (optional) Output mode for the search results. Can be "content" (default, shows file content with matches) or "files_with_matches" (only shows the list of files that contain matches without content).
+
 Usage:
 <search_files>
 <path>Directory path here</path>
 <regex>Your regex pattern here</regex>
 <file_pattern>file pattern here (optional)</file_pattern>
+<output_mode>content or files_with_matches (optional)</output_mode>
 </search_files>
 
+Example: Requesting to search for 'abc' in .ts files and .js files in the current directory
+<search_files>
+<path>.</path>
+<regex>abc</regex>
+<file_pattern>*.{ts,js}</file_pattern>
+<output_mode>files_with_matches</output_mode>
+</search_files>
+
+
+### Glob Tips:
+
+- You can use the "files_with_matches" mode, fill in ".*" for the regex content to quickly match the file names you need.
+- Use this method when you need to find files by name patterns as a fast file pattern matching tool.
+- Supports glob patterns like "**/*.js" or "src/**/*.ts"
+
 Example: Requesting to search for all .ts files in the current directory
 <search_files>
 <path>.</path>
 <regex>.*</regex>
 <file_pattern>*.ts</file_pattern>
-</search_files>`
+<output_mode>files_with_matches</output_mode>
+</search_files>
+`
 }
diff --git a/src/core/prompts/tools/update-todo-list.ts b/src/core/prompts/tools/update-todo-list.ts
index 30100617..9ff08aca 100644
--- a/src/core/prompts/tools/update-todo-list.ts
+++ b/src/core/prompts/tools/update-todo-list.ts
@@ -7,7 +7,10 @@ export function getUpdateTodoListDescription(args?: ToolArgs): string {
 	return `## update_todo_list
 
 **Description:**
-Replace the entire TODO list with an updated checklist reflecting the current state. Always provide the full list; the system will overwrite the previous one. This tool is designed for step-by-step task tracking, allowing you to confirm completion of each step before updating, update multiple task statuses at once (e.g., mark one as completed and start the next), and dynamically add new todos discovered during long or complex tasks.
+Use this tool to create and manage a structured task list for your current coding session. This helps you track progress, organize complex tasks, and demonstrate thoroughness to the user.
+It also helps the user understand the progress of the task and overall progress of their requests.
+
+Create a TODO list or replace the entire TODO list with an updated checklist reflecting the current state. Always provide the full list; if the task list is already included, the system will overwrite the previous one. This tool is designed for step-by-step task tracking, allowing you to confirm completion of each step before updating, update multiple task statuses at once (e.g., mark one as completed and start the next), and dynamically add new todos discovered during long or complex tasks.
 
 **Checklist Format:**
 - Use a single-level markdown checklist (no nesting or subtasks).
@@ -20,7 +23,7 @@ Replace the entire TODO list with an updated checklist reflecting the current st
 **Status Rules:**
 - [ ] = pending (not started)
 - [x] = completed (fully finished, no unresolved issues)
-- [-] = in_progress (currently being worked on)
+- [-] = in progress (currently being worked on)
 
 **Core Principles:**
 - Before updating, always confirm which todos have been completed since the last update.
@@ -29,48 +32,226 @@ Replace the entire TODO list with an updated checklist reflecting the current st
 - Do not remove any unfinished todos unless explicitly instructed.
 - Always retain all unfinished tasks, updating their status as needed.
 - Only mark a task as completed when it is fully accomplished (no partials, no unresolved dependencies).
-- If a task is blocked, keep it as in_progress and add a new todo describing what needs to be resolved.
+- If a task is blocked, keep it as in progress and add a new todo describing what needs to be resolved.
 - Remove tasks only if they are no longer relevant or if the user requests deletion.
+- Tasks are divided into three types: \`analysis\`, \`planning\`, \`editing\`. When creating a to-do task, please categorize it into these three types and mark the beginning of the task with [xxx]
 
 **Usage Example:**
 <update_todo_list>
 <todos>
-[x] Analyze requirements
-[x] Design architecture
-[-] Implement core logic
-[ ] Write tests
-[ ] Update documentation
+[x] [analysis] Analyze requirements
+[x] [planning] Design architecture
+[-] [editing] Implement core logic
+[ ] [editing] Write tests
+[ ] [editing] Update documentation
 </todos>
 </update_todo_list>
 
 *After completing "Implement core logic" and starting "Write tests":*
 <update_todo_list>
 <todos>
-[x] Analyze requirements
-[x] Design architecture
-[x] Implement core logic
-[-] Write tests
-[ ] Update documentation
-[ ] Add performance benchmarks
+[x] [analysis] Analyze requirements
+[x] [planning] Design architecture
+[x] [editing] Implement core logic
+[-] [editing] Write tests
+[ ] [editing] Update documentation
+[ ] [editing] Add performance benchmarks
 </todos>
 </update_todo_list>
 
-**When to Use:**
-- The task is complicated or involves multiple steps or requires ongoing tracking.
-- You need to update the status of several todos at once.
-- New actionable items are discovered during task execution.
-- The user requests a todo list or provides multiple tasks.
-- The task is complex and benefits from clear, stepwise progress tracking.
-
-**When NOT to Use:**
-- There is only a single, trivial task.
-- The task can be completed in one or two simple steps.
-- The request is purely conversational or informational.
-
-**Task Management Guidelines:**
-- Mark task as completed immediately after all work of the current task is done.
-- Start the next task by marking it as in_progress.
-- Add new todos as soon as they are identified.
-- Use clear, descriptive task names.
+**When to Use This Tool:**
+ 
+Use this tool proactively in these scenarios:
+
+1.  Complex multi-step tasks - When a task requires 3 or more distinct steps or actions
+2.  Non-trivial and complex tasks - Tasks that require careful planning or multiple operations
+3.  User explicitly requests todo list - When the user directly asks you to use the todo list
+4.  User provides multiple tasks - When users provide a list of things to be done (numbered or comma-separated)
+5.  After receiving new instructions - Immediately capture user requirements as todos
+6.  When you start working on a task - Mark it as [-](\`in progress\`) BEFORE beginning work. Ideally you should only have one todo as [-](\`in progress)\` at a time
+7.  After completing a task - Mark it as [x](\`completed\`) and add any new follow-up tasks discovered during implementation
+
+
+**When NOT to Use This Tool:**
+
+Skip using this tool when:
+1.  There is only a single, straightforward task
+2.  The task is trivial and tracking it provides no organizational benefit
+3.  The task can be completed in less than 3 trivial steps
+4.  The task is purely conversational or informational
+
+> **NOTE** that you should not use this tool if there is only one trivial task to do. In this case you are better off just doing the task directly.
+
+
+
+### Examples of When to Use the Todo List
+
+#### Example 1
+
+> **User:** I want to add a dark mode toggle to the application settings. Make sure you run the tests and build when you're done!
+>
+> **Assistant:** I'll help add a dark mode toggle to your application settings. Let me create a todo list to track this implementation.
+>
+> *Creates todo list with the following items:*
+> 1.  Creating dark mode toggle component in Settings page
+> 2.  Adding dark mode state management (context/store)
+> 3.  Implementing CSS-in-JS styles for dark theme
+> 4.  Updating existing components to support theme switching
+> 5.  Running tests and build process, addressing any failures or errors that occur
+>
+> *Begins working on the first task*
+>
+> **Reasoning:**
+> The assistant used the todo list because:
+> 1.  Adding dark mode is a multi-step feature requiring UI, state management, and styling changes
+> 2.  The user explicitly requested tests and build be run afterward
+> 3.  The assistant inferred that tests and build need to pass by adding "Ensure tests and build succeed" as the final task
+>
+#### Example 2
+
+> **User:** Help me rename the function \`getCwd\` to \`getCurrentWorkingDirectory\` across my project
+>
+> **Assistant:** Let me first search through your codebase to find all occurrences of 'getCwd'.
+>
+> *Uses \`grep\` or search tools to locate all instances of \`getCwd\` in the codebase*
+>
+> **Assistant:** I've found 15 instances of 'getCwd' across 8 different files. Let me create a todo list to track these changes.
+>
+> *Creates todo list with specific items for each file that needs updating*
+>
+> **Reasoning:**
+> The assistant used the todo list because:
+> 1.  First, the assistant searched to understand the scope of the task
+> 2.  Upon finding multiple occurrences across different files, it determined this was a complex task with multiple steps
+> 3.  The todo list helps ensure every instance is tracked and updated systematically
+> 4.  This approach prevents missing any occurrences and maintains code consistency
+
+#### Example 3
+
+> **User:** I need to implement these features for my e-commerce site: user registration, product catalog, shopping cart, and checkout flow.
+>
+> **Assistant:** I'll help implement these features. First, let's add all the features to the todo list.
+>
+> *Creates a todo list breaking down each feature into specific tasks based on the project architecture*
+>
+> **Assistant:** Let's start with user registration. This will involve creating database models, API endpoints, and frontend forms that integrate with your existing authentication system.
+>
+> **Reasoning:**
+> The assistant used the todo list because:
+> 1.  The user provided multiple complex features to implement in a comma separated list
+> 2.  The todo list helps organize these large features into manageable tasks
+> 3.  This approach allows for tracking progress across the entire implementation
+
+#### Example 4
+
+> **User:** Can you help optimize my React application? It's rendering slowly and has performance issues.
+>
+> **Assistant:** I'll help optimize your React application. First, let me examine your codebase to identify potential performance bottlenecks.
+>
+> *Reviews component structure, render patterns, state management, and data fetching*
+>
+> **Assistant:** After analyzing your codebase, I've identified several performance issues. Let me create a todo list to track our optimization efforts.
+>
+> *Creates todo list with items like: 1) Implementing memoization for expensive calculations in ProductList, 2) Adding virtualization for long lists in Dashboard, 3) Optimizing image loading in Gallery component, 4) Fixing state update loops in ShoppingCart, 5) Reviewing bundle size and implementing code splitting*
+>
+> Let's start by implementing memoization for the expensive calculations in your ProductList component.
+>
+> **Reasoning:**
+> The assistant used the todo list because:
+> 1.  First, the assistant examined the codebase to identify specific performance issues
+> 2.  Based on this analysis, it identified multiple optimization opportunities
+> 3.  Performance optimization is a non-trivial task requiring multiple steps
+> 4.  The todo list helps methodically track improvements across different components
+> 5.  This systematic approach ensures all performance bottlenecks are addressed
+
+
+### Examples of When NOT to Use the Todo List
+
+#### Example 1
+
+> **User:** How do I print 'Hello World' in Python?
+>
+> **Assistant:** In Python, you can print "Hello World" with this simple code:
+>
+> \`\`\`python
+> print("Hello World")
+> \`\`\`
+>
+> This will output the text "Hello World" to the console when executed.
+>
+> **Reasoning:**
+> The assistant did not use the todo list because this is a single, trivial task that can be completed in one step. There's no need to track multiple tasks or steps for such a straightforward request.
+
+#### Example 2
+
+> **User:** What does the \`git status\` command do?
+>
+> **Assistant:** The \`git status\` command shows the current state of your working directory and staging area. It displays which changes have been staged, which haven't, and which files aren't being tracked by Git. This is a fundamental command for understanding the current state of your repository before making commits.
+>
+> **Reasoning:**
+> The assistant did not use the todo list because this is an informational request with no actual coding task to complete. The user is simply asking for an explanation, not for the assistant to perform multiple steps or tasks.
+
+#### Example 3
+
+> **User:** Can you add a comment to the \`calculateTotal\` function to explain what it does?
+>
+> **Assistant:** Sure, let me add a comment to the \`calculateTotal\` function to explain what it does.
+>
+> *Uses the Edit tool to add a comment to the \`calculateTotal\` function*
+>
+> **Reasoning:**
+> The assistant did not use the todo list because this is a single, straightforward task confined to one location in the code. Adding a comment doesn't require tracking multiple steps or systematic organization.
+
+#### Example 4
+
+> **User:** Run \`npm install\` for me and tell me what happens.
+>
+> **Assistant:** I'll run the \`npm install\` command for you.
+>
+> *Executes: \`npm install\`*
+>
+> The command completed successfully. Here's the output:
+> [Output of \`npm install\` command]
+>
+> All dependencies have been installed according to your \`package.json\` file.
+>
+> **Reasoning:**
+> The assistant did not use the todo list because this is a single command execution with immediate results. There are no multiple steps to track or organize, making the todo list unnecessary for this straightforward task.
+
+
+### Task States and Management
+
+1.  **Task States**: Use these states to track progress:
+    *   \`pending\`: Task not yet started
+    *   \`in progress\`: Currently working on (limit to ONE task at a time)
+    *   \`completed\`: Task finished successfully
+
+    **IMPORTANT**: Task descriptions must have two forms:
+    *   \`content\`: The imperative form describing what needs to be done (e.g., "Run tests", "Build the project")
+    *   \`activeForm\`: The present continuous form shown during execution (e.g., "Running tests", "Building the project")
+
+2.  **Task Management**:
+    *   Update task status in real-time as you work
+    *   Mark tasks complete IMMEDIATELY after finishing (don't batch completions)
+    *   Exactly ONE task must be \`in progress\` at any time (not less, not more)
+    *   Complete current tasks before starting new ones
+    *   Remove tasks that are no longer relevant from the list entirely
+
+3.  **Task Completion Requirements**:
+    *   ONLY mark a task as completed when you have FULLY accomplished it
+    *   If you encounter errors, blockers, or cannot finish, keep the task as \`in progress\`
+    *   When blocked, create a new task describing what needs to be resolved
+    *   Never mark a task as completed if:
+        *   Tests are failing
+        *   Implementation is partial
+        *   You encountered unresolved errors
+        *   You couldn't find necessary files or dependencies
+
+4.  **Task Breakdown**:
+    *   Create specific, actionable items
+    *   Break complex tasks into smaller, manageable steps
+    *   Use clear, descriptive task names
+
+When in doubt, use this tool. Being proactive with task management demonstrates attentiveness and ensures you complete all requirements successfully.
 `
 }
diff --git a/src/core/prompts/tools/use-mcp-tool.ts b/src/core/prompts/tools/use-mcp-tool.ts
index ac9ef5b0..aa168ffa 100644
--- a/src/core/prompts/tools/use-mcp-tool.ts
+++ b/src/core/prompts/tools/use-mcp-tool.ts
@@ -4,6 +4,7 @@ export function getUseMcpToolDescription(args: ToolArgs): string | undefined {
 	if (!args.mcpHub) {
 		return undefined
 	}
+
 	return `## use_mcp_tool
 Description: Request to use a tool provided by a connected MCP server. Each MCP server can provide multiple tools with different capabilities. Tools have defined input schemas that specify required and optional parameters.
 Parameters:
diff --git a/src/core/task/Task.ts b/src/core/task/Task.ts
index 9d68640f..f4abc4f3 100644
--- a/src/core/task/Task.ts
+++ b/src/core/task/Task.ts
@@ -47,7 +47,7 @@ import { EXPERIMENT_IDS, experiments } from "../../shared/experiments"
 import { getModelMaxOutputTokens } from "../../shared/api"
 
 // services
-import { UrlContentFetcher } from "../../services/browser/UrlContentFetcher"
+import { UrlContentFetcher } from "../../services/browser/UrlContentFetcher-riddler"
 import { BrowserSession } from "../../services/browser/BrowserSession"
 import { McpHub } from "../../services/mcp/McpHub"
 import { McpServerManager } from "../../services/mcp/McpServerManager"
@@ -78,7 +78,7 @@ import { ClineProvider } from "../webview/ClineProvider"
 import { MultiSearchReplaceDiffStrategy } from "../diff/strategies/multi-search-replace"
 import { MultiFileSearchReplaceDiffStrategy } from "../diff/strategies/multi-file-search-replace"
 import { readApiMessages, saveApiMessages, readTaskMessages, saveTaskMessages, taskMetadata } from "../task-persistence"
-import { getEnvironmentDetails } from "../environment/getEnvironmentDetails"
+import { getEnvironmentDetails, getUserSuggestions } from "../environment/getEnvironmentDetails"
 import {
 	type CheckpointDiffOptions,
 	type CheckpointRestoreOptions,
@@ -90,9 +90,14 @@ import {
 import { processUserContentMentions } from "../mentions/processUserContentMentions"
 import { ApiMessage } from "../task-persistence/apiMessages"
 import { getMessagesSinceLastSummary, summarizeConversation } from "../condense"
+import { summarizeSubTask } from "../summarize-subtask"
 import { maybeRemoveImageBlocks } from "../../api/transform/image-cleaning"
 import { restoreTodoListForTask } from "../tools/updateTodoListTool"
 
+
+import { userExecuteCommand } from "../tools/executeCommandTool"
+
+
 const MAX_EXPONENTIAL_BACKOFF_SECONDS = 600 // 10 minutes
 
 export type TaskEvents = {
@@ -241,6 +246,7 @@ export class Task extends EventEmitter<TaskEvents> {
 	consecutiveMistakeLimit: number
 	consecutiveMistakeCountForApplyDiff: Map<string, number> = new Map()
 	toolUsage: ToolUsage = {}
+	public toolSequence: string[] = [];
 
 	// Checkpoints
 	enableCheckpoints: boolean
@@ -260,6 +266,11 @@ export class Task extends EventEmitter<TaskEvents> {
 	didAlreadyUseTool = false
 	didCompleteReadingStream = false
 
+	// Riddler
+	postprocess = {
+		_execute_command: undefined as string | undefined,
+	}
+
 	constructor({
 		provider,
 		apiConfiguration,
@@ -800,6 +811,83 @@ export class Task extends EventEmitter<TaskEvents> {
 		)
 	}
 
+	public async summarizeSubTaskContext(): Promise<string> {
+		const systemPrompt = await this.getSystemPrompt()
+
+		// Get condensing configuration
+		// Using type assertion to handle the case where Phase 1 hasn't been implemented yet
+		const state = await this.providerRef.deref()?.getState()
+		const customCondensingPrompt = state ? (state as any).customCondensingPrompt : undefined
+		const condensingApiConfigId = state ? (state as any).condensingApiConfigId : undefined
+		const listApiConfigMeta = state ? (state as any).listApiConfigMeta : undefined
+
+		// Determine API handler to use
+		let condensingApiHandler: ApiHandler | undefined
+		if (condensingApiConfigId && listApiConfigMeta && Array.isArray(listApiConfigMeta)) {
+			// Using type assertion for the id property to avoid implicit any
+			const matchingConfig = listApiConfigMeta.find((config: any) => config.id === condensingApiConfigId)
+			if (matchingConfig) {
+				const profile = await this.providerRef.deref()?.providerSettingsManager.getProfile({
+					id: condensingApiConfigId,
+				})
+				// Ensure profile and apiProvider exist before trying to build handler
+				if (profile && profile.apiProvider) {
+					condensingApiHandler = buildApiHandler(profile)
+				}
+			}
+		}
+
+		const { contextTokens: prevContextTokens } = this.getTokenUsage()
+		const {
+			messages,
+			summary,
+			cost,
+			newContextTokens = 0,
+			error,
+			inputTokens = 0,
+			outputTokens = 0,
+			cacheWriteTokens = 0,
+			cacheReadTokens = 0,
+		} = await summarizeSubTask(
+			this,
+			this.apiConversationHistory,
+			this.api, // Main API handler (fallback)
+			systemPrompt, // Default summarization prompt (fallback)
+			this.taskId,
+			prevContextTokens,
+			false, // manual trigger
+			customCondensingPrompt, // User's custom prompt
+			condensingApiHandler, // Specific handler for condensing
+		)
+		
+		const maybe_cost:number = cost > 0 ? cost :
+			calculateApiCostAnthropic(
+				this.api.getModel().info,
+				inputTokens,
+				outputTokens,
+				cacheWriteTokens,
+				cacheReadTokens,
+			)
+		// Record cost using the new cost_tracking message type
+		if (maybe_cost > 0) {
+			const contextCondense: ContextCondense = { summary, cost:maybe_cost, newContextTokens, prevContextTokens }
+			await this.say(
+				"cost_tracking",
+				undefined /* text */,
+				undefined /* images */,
+				false /* partial */,
+				undefined /* checkpoint */,
+				undefined /* progressStatus */,
+				{ isNonInteractive: true } /* options */,
+				contextCondense,
+			)
+		}
+		if (error) {
+			return ""
+		}
+		return summary
+	}
+
 	async say(
 		type: ClineSay,
 		text?: string,
@@ -1415,6 +1503,7 @@ export class Task extends EventEmitter<TaskEvents> {
 			fileContextTracker: this.fileContextTracker,
 			rooIgnoreController: this.rooIgnoreController,
 			showRooIgnoredFiles,
+			globalStoragePath: this.globalStoragePath,
 			includeDiagnosticMessages,
 			maxDiagnosticMessages,
 			maxReadFileLine,
@@ -1424,8 +1513,20 @@ export class Task extends EventEmitter<TaskEvents> {
 
 		// Add environment details as its own text block, separate from tool
 		// results.
-		const finalUserContent = [...parsedUserContent, { type: "text" as const, text: environmentDetails }]
+		let userExecuteCommandResult: string | undefined = undefined
+		if (this.postprocess._execute_command) {
+			const cmd = this.postprocess._execute_command
+			this.postprocess._execute_command = undefined
+			userExecuteCommandResult = await userExecuteCommand(this, cmd)
+		}
 
+		const finalUserContent = [
+			...parsedUserContent, 
+			...(userExecuteCommandResult !== undefined ? [{ type: "text" as const, text: `User called the command in the task above in the local terminal, and the terminal displayed the following results (the results are in the <user_execute_command_result></user_execute_command_result> tag):\n<user_execute_command_result>\n${userExecuteCommandResult}\n</user_execute_command_result>` }] : []),
+			...(this.parentTask && includeFileDetails ? [{ type: "text" as const, text: "- IMPORTANT: **SUBTASK RULES** - When you complete your tasks and finally call the \`attempt_completion\` tool for summarization, you MUST describe in more detail all the tasks you completed and the conclusions you reached." }] : []), 
+			{ type: "text" as const, text: environmentDetails },
+		]
+		
 		await this.addToApiConversationHistory({ role: "user", content: finalUserContent })
 		TelemetryService.instance.captureConversationMessage(this.taskId, "user")
 
@@ -1449,6 +1550,8 @@ export class Task extends EventEmitter<TaskEvents> {
 			let inputTokens = 0
 			let outputTokens = 0
 			let totalCost: number | undefined
+			let tps: number = 0
+			let latency: number = 0
 
 			// We can't use `api_req_finished` anymore since it's a unique case
 			// where it could come after a streaming message (i.e. in the middle
@@ -1465,6 +1568,8 @@ export class Task extends EventEmitter<TaskEvents> {
 					tokensOut: outputTokens,
 					cacheWrites: cacheWriteTokens,
 					cacheReads: cacheReadTokens,
+					tps: tps ?? 0, // tokens per second
+					latency: latency ?? 0, // latency in milliseconds
 					cost:
 						totalCost ??
 						calculateApiCostAnthropic(
@@ -1561,6 +1666,8 @@ export class Task extends EventEmitter<TaskEvents> {
 							outputTokens += chunk.outputTokens
 							cacheWriteTokens += chunk.cacheWriteTokens ?? 0
 							cacheReadTokens += chunk.cacheReadTokens ?? 0
+							latency += chunk.latency ?? 0
+							tps = chunk.tps ?? 0
 							totalCost = chunk.totalCost
 							break
 						case "text": {
@@ -1968,6 +2075,22 @@ export class Task extends EventEmitter<TaskEvents> {
 			({ role, content }) => ({ role, content }),
 		)
 
+		const userSuggestions = await getUserSuggestions(this)
+		
+		// 如果cleanConversationHistory最后一个对话角色是user，且是一个数组，且userSuggestions不是undefined，
+		// 则把userSuggestions加入数组的最后一个，属性是text
+		if (cleanConversationHistory.length > 0) {
+			const lastMessage = cleanConversationHistory[cleanConversationHistory.length - 1]
+			if (lastMessage.role === "user" && Array.isArray(lastMessage.content)) {
+				if (userSuggestions !== undefined) {
+					lastMessage.content.push({
+						type: "text",
+						text: `<user_suggestions>\n${userSuggestions}\nThis is just a gentle reminder - ignore if not applicable.\n</user_suggestions>`
+					})
+				}
+			}
+		}
+
 		// Check if we've reached the maximum number of auto-approved requests
 		const maxRequests = state?.allowedMaxRequests || Infinity
 
@@ -2114,7 +2237,7 @@ export class Task extends EventEmitter<TaskEvents> {
 		if (!this.toolUsage[toolName]) {
 			this.toolUsage[toolName] = { attempts: 0, failures: 0 }
 		}
-
+		this.toolSequence.push(toolName);
 		this.toolUsage[toolName].attempts++
 	}
 
@@ -2122,7 +2245,6 @@ export class Task extends EventEmitter<TaskEvents> {
 		if (!this.toolUsage[toolName]) {
 			this.toolUsage[toolName] = { attempts: 0, failures: 0 }
 		}
-
 		this.toolUsage[toolName].failures++
 
 		if (error) {
diff --git a/src/core/tools/applyDiffTool.ts b/src/core/tools/applyDiffTool.ts
index 903e3c84..b1f96ce0 100644
--- a/src/core/tools/applyDiffTool.ts
+++ b/src/core/tools/applyDiffTool.ts
@@ -212,6 +212,18 @@ export async function applyDiffToolLegacy(
 
 				// Call saveChanges to update the DiffViewProvider properties
 				await cline.diffViewProvider.saveChanges(diagnosticsEnabled, writeDelayMs)
+
+				let newContent: string | undefined = await fs.readFile(absolutePath, "utf-8")
+
+				const agentEdits = formatResponse.createPrettyPatch(absolutePath, originalContent, newContent ?? undefined)
+				const say: ClineSayTool = {
+					tool: (!fileExists) ? "newFileCreated" : "editedExistingFile",
+					path: getReadablePath(cline.cwd, relPath),
+					diff: `# agentEdits\n${agentEdits}\n`,
+				}
+	
+				// Send the user feedback
+				await cline.say("user_feedback_diff", JSON.stringify(say))
 			}
 
 			// Track file edit operation
diff --git a/src/core/tools/attemptCompletionTool.ts b/src/core/tools/attemptCompletionTool.ts
index ef788185..2d972aa0 100644
--- a/src/core/tools/attemptCompletionTool.ts
+++ b/src/core/tools/attemptCompletionTool.ts
@@ -98,9 +98,11 @@ export async function attemptCompletionTool(
 				if (!didApprove) {
 					return
 				}
+				
+				const summary = await cline.summarizeSubTaskContext()
 
 				// tell the provider to remove the current subtask and resume the previous task in the stack
-				await cline.providerRef.deref()?.finishSubTask(result)
+				await cline.providerRef.deref()?.finishSubTask(`## Result \n${result} \n\n## Summary  \n${summary}\n\n`)
 				return
 			}
 
diff --git a/src/core/tools/codebaseSearchTool.ts b/src/core/tools/codebaseSearchTool.ts
index 236b0663..18c7a64b 100644
--- a/src/core/tools/codebaseSearchTool.ts
+++ b/src/core/tools/codebaseSearchTool.ts
@@ -17,7 +17,7 @@ export async function codebaseSearchTool(
 	removeClosingTag: RemoveClosingTag,
 ) {
 	const toolName = "codebase_search"
-	const workspacePath = getWorkspacePath()
+	const workspacePath = (cline.cwd && cline.cwd.trim() !== '') ? cline.cwd : getWorkspacePath()
 
 	if (!workspacePath) {
 		// This case should ideally not happen if Cline is initialized correctly
@@ -29,6 +29,13 @@ export async function codebaseSearchTool(
 	let query: string | undefined = block.params.query
 	let directoryPrefix: string | undefined = block.params.path
 
+
+	if (query === undefined) {
+		await getSummary(cline, block, askApproval, handleError, pushToolResult, removeClosingTag)
+		return
+	}
+
+
 	query = removeClosingTag("query", query)
 
 	if (directoryPrefix) {
@@ -132,7 +139,7 @@ ${jsonResult.results
 		(result) => `File path: ${result.filePath}
 Score: ${result.score}
 Lines: ${result.startLine}-${result.endLine}
-Code Chunk: ${result.codeChunk}
+Code Chunk: \n${result.codeChunk}
 `,
 	)
 	.join("\n")}`
@@ -142,3 +149,129 @@ Code Chunk: ${result.codeChunk}
 		await handleError(toolName, error) // Use the standard error handler
 	}
 }
+
+
+
+async function getSummary(
+	cline: Task,
+	block: ToolUse,
+	askApproval: AskApproval,
+	handleError: HandleError,
+	pushToolResult: PushToolResult,
+	removeClosingTag: RemoveClosingTag
+) {
+	const toolName = "codebase_search"
+	const workspacePath = getWorkspacePath()
+
+	if (!workspacePath) {
+		// This case should ideally not happen if Cline is initialized correctly
+		await handleError(toolName, new Error("Could not determine workspace path."))
+		return
+	}
+
+	// --- Parameter Extraction and Validation ---
+	let directoryPrefix: string | undefined = block.params.path
+	
+	if (directoryPrefix) {
+		directoryPrefix = removeClosingTag("path", directoryPrefix)
+		directoryPrefix = path.normalize(directoryPrefix)
+	} else {
+		directoryPrefix = '.'
+	}
+
+	const sharedMessageProps = {
+		tool: "codebaseSearch",
+		query: "（获取摘要）",
+		path: directoryPrefix,
+		isOutsideWorkspace: false,
+	}
+
+	if (block.partial) {
+		await cline.ask("tool", JSON.stringify(sharedMessageProps), block.partial).catch(() => {})
+		return
+	}
+
+	// if (!query) {
+	// 	cline.consecutiveMistakeCount++
+	// 	pushToolResult(await cline.sayAndCreateMissingParamError(toolName, "query"))
+	// 	return
+	// }
+
+	const didApprove = await askApproval("tool", JSON.stringify(sharedMessageProps))
+	if (!didApprove) {
+		pushToolResult(formatResponse.toolDenied())
+		return
+	}
+
+	cline.consecutiveMistakeCount = 0
+
+	// --- Core Logic ---
+	try {
+		const context = cline.providerRef.deref()?.context
+		if (!context) {
+			throw new Error("Extension context is not available.")
+		}
+
+		const manager = CodeIndexManager.getInstance(context)
+
+		if (!manager) {
+			throw new Error("CodeIndexManager is not available.")
+		}
+
+		if (!manager.isFeatureEnabled) {
+			throw new Error("Code Indexing is disabled in the settings.")
+		}
+		if (!manager.isFeatureConfigured) {
+			throw new Error("Code Indexing is not configured (Missing OpenAI Key or Qdrant URL).")
+		}
+
+		const summaryResults: VectorStoreSearchResult[] = await manager.searchSummary(directoryPrefix ?? "")
+
+		// 3. Format and push results
+		if (!summaryResults || summaryResults.length === 0) {
+			pushToolResult(`No summary found in path: "${directoryPrefix}"`) // Use simple string for no results
+			return
+		}
+
+		const jsonResult = {
+			query: "（获取摘要）",
+			results: [],
+		} as {
+			query: string
+			results: Array<{
+				filePath: string
+				score: number
+				startLine: number
+				endLine: number
+				codeChunk: string
+			}>
+		}
+
+		summaryResults.forEach((result) => {
+			if (!result.payload) return
+			if (!("filePath" in result.payload)) return
+
+			const relativePath = vscode.workspace.asRelativePath(result.payload.filePath, false)
+
+			jsonResult.results.push({
+				filePath: relativePath,
+				score: result.score,
+				startLine: result.payload.startLine,
+				endLine: result.payload.endLine,
+				codeChunk: result.payload.codeChunk.trim(),
+			})
+		})
+
+
+		// Send results to UI
+		const payload = { tool: "codebaseSearch", content: jsonResult }
+		await cline.say("codebase_search_result", JSON.stringify(payload))
+
+		// Push results to AI
+		const output = `# Codebase summary in ${directoryPrefix}:\n\n${jsonResult.results.map(result => `## File: ${result.filePath}\n${result.codeChunk}`).join("\n\n")}`
+
+		pushToolResult(output)
+	} catch (error: any) {
+		await handleError(toolName, error) // Use the standard error handler
+	}
+}
\ No newline at end of file
diff --git a/src/core/tools/executeCommandTool.ts b/src/core/tools/executeCommandTool.ts
index c346526a..95c80e6a 100644
--- a/src/core/tools/executeCommandTool.ts
+++ b/src/core/tools/executeCommandTool.ts
@@ -362,3 +362,124 @@ export async function executeCommand(
 		]
 	}
 }
+
+
+
+
+export async function userExecuteCommand(
+	task: Task,
+	cmd: string,
+): Promise<string> {
+	const handleError = async (action: string, error: Error) => {
+		const errorString = `Error ${action}: ${cmd}`
+
+		await task.say(
+			"error",
+			`Error ${action}:\n${cmd}`,
+		)
+
+		return errorString
+	}
+
+	const askApproval = async (
+		cmd:string
+	) => {
+		const { response } = await task.ask(
+			"command",
+			cmd,
+			false,
+			undefined,
+			true,
+		)
+
+		if (response !== "yesButtonClicked") {
+			throw new Error("loggic error")
+		}
+
+		return true
+	}
+	
+	try {
+		if (!cmd) {
+			return "Error: command is empty!"
+		}
+
+		task.consecutiveMistakeCount = 0
+
+		cmd = unescapeHtmlEntities(cmd) // Unescape HTML entities.
+
+		const didApprove = await askApproval(cmd)
+		delay(100)
+		if (!didApprove) {
+			return "Error: command rejected!"
+		}
+
+		const executionId = task.lastMessageTs?.toString() ?? Date.now().toString()
+		const provider = await task.providerRef.deref()
+		const providerState = await provider?.getState()
+
+		const {
+			terminalOutputLineLimit = 500,
+			terminalOutputCharacterLimit = DEFAULT_TERMINAL_OUTPUT_CHARACTER_LIMIT,
+			terminalShellIntegrationDisabled = false,
+		} = providerState ?? {}
+
+		// Get command execution timeout from VSCode configuration (in seconds)
+		const commandExecutionTimeoutSeconds = vscode.workspace
+			.getConfiguration(Package.name)
+			.get<number>("commandExecutionTimeout", 0)
+
+		// Get command timeout allowlist from VSCode configuration
+		const commandTimeoutAllowlist = vscode.workspace
+			.getConfiguration(Package.name)
+			.get<string[]>("commandTimeoutAllowlist", [])
+
+		// Check if command matches any prefix in the allowlist
+		const isCommandAllowlisted = commandTimeoutAllowlist.some((prefix) => cmd!.startsWith(prefix.trim()))
+
+		// Convert seconds to milliseconds for internal use, but skip timeout if command is allowlisted
+		const commandExecutionTimeout = isCommandAllowlisted ? 0 : commandExecutionTimeoutSeconds * 1000
+
+		const options: ExecuteCommandOptions = {
+			executionId,
+			command:cmd,
+			customCwd:task.cwd,
+			terminalShellIntegrationDisabled,
+			terminalOutputLineLimit,
+			terminalOutputCharacterLimit,
+			commandExecutionTimeout,
+		}
+
+		try {
+			const [rejected, result] = await executeCommand(task, options)
+
+			if (rejected) {
+				return "Error: command rejected!"
+			}
+
+			return result as string
+		} catch (error: unknown) {
+			const status: CommandExecutionStatus = { executionId, status: "fallback" }
+			provider?.postMessageToWebview({ type: "commandExecutionStatus", text: JSON.stringify(status) })
+			await task.say("shell_integration_warning")
+
+			if (error instanceof ShellIntegrationError) {
+				const [rejected, result] = await executeCommand(task, {
+					...options,
+					terminalShellIntegrationDisabled: true,
+				})
+
+				if (rejected) {
+					return "Error: command rejected!"
+				}
+
+				return result as string
+			} else {
+				return(`Command failed to execute in terminal due to a shell integration error.`)
+			}
+		}
+	} catch (error) {
+		return await handleError("executing command", error)
+	}
+}
+
diff --git a/src/core/tools/multiApplyDiffTool.ts b/src/core/tools/multiApplyDiffTool.ts
index db514d2b..c47aafe4 100644
--- a/src/core/tools/multiApplyDiffTool.ts
+++ b/src/core/tools/multiApplyDiffTool.ts
@@ -407,7 +407,7 @@ Original error: ${errorMessage}`
 			const fileExists = opResult.fileExists!
 
 			try {
-				let originalContent: string | null = await fs.readFile(absolutePath, "utf-8")
+				let originalContent: string = await fs.readFile(absolutePath, "utf-8")
 				let successCount = 0
 				let formattedError = ""
 
@@ -426,7 +426,7 @@ Original error: ${errorMessage}`
 				}
 
 				// Release the original content from memory as it's no longer needed
-				originalContent = null
+				// originalContent = null
 
 				if (!diffResult.success) {
 					cline.consecutiveMistakeCount++
@@ -611,6 +611,20 @@ ${errorDetails ? `\nTechnical details:\n${errorDetails}\n` : ""}
 					}
 				}
 
+				
+				let newContent: string | null = await fs.readFile(absolutePath, "utf-8")
+				
+				const agentEdits = formatResponse.createPrettyPatch(absolutePath, originalContent ?? "", newContent ?? undefined)
+				const say: ClineSayTool = {
+					tool: (!fileExists) ? "newFileCreated" : "editedExistingFile",
+					path: getReadablePath(cline.cwd, relPath),
+					diff: `# agentEdits\n${agentEdits}\n`,
+				}
+	
+				// Send the user feedback
+				await cline.say("user_feedback_diff", JSON.stringify(say))
+				
+
 				// Track file edit operation
 				await cline.fileContextTracker.trackFileContext(relPath, "roo_edited" as RecordSource)
 
diff --git a/src/core/tools/newTaskTool.ts b/src/core/tools/newTaskTool.ts
index cc56659d..1cbbe325 100644
--- a/src/core/tools/newTaskTool.ts
+++ b/src/core/tools/newTaskTool.ts
@@ -6,6 +6,9 @@ import { defaultModeSlug, getModeBySlug } from "../../shared/modes"
 import { formatResponse } from "../prompts/responses"
 import { t } from "../../i18n"
 
+import { ApiMessage } from "../task-persistence/apiMessages"
+import { getMessagesSinceLastSummary } from "../condense"
+
 export async function newTaskTool(
 	cline: Task,
 	block: ToolUse,
@@ -87,6 +90,25 @@ export async function newTaskTool(
 				return
 			}
 
+			const parentMessages:ApiMessage[] = [
+				...getMessagesSinceLastSummary(cline.apiConversationHistory), 
+				{
+					role: "user",
+					content: `现在得你，是一个由主要智能体创建的子智能体，用于完成父任务中的一个子任务。` +
+						`在此之前的对话都是主要智能体完成父任务时，所进行的对话上下文记录`,
+					ts: Date.now(),
+				},
+				{
+					role: "assistant",
+					content: `那么作为一个子智能体，我当前的任务是什么呢？`,
+					ts: Date.now(),
+				}
+			]
+			// 将父任务的对话上下文传递给子任务
+			if (cline.apiConversationHistory && cline.apiConversationHistory.length > 0) {
+				await newCline.overwriteApiConversationHistory(parentMessages)
+			}
+
 			// Now switch the newly created task to the desired mode
 			await provider.handleModeSwitch(mode)
 
diff --git a/src/core/tools/readFileTool.ts b/src/core/tools/readFileTool.ts
index 01427f4d..4b583791 100644
--- a/src/core/tools/readFileTool.ts
+++ b/src/core/tools/readFileTool.ts
@@ -578,7 +578,7 @@ export async function readFileTool(
 						if (defResult) {
 							xmlInfo += `<list_code_definition_names>${defResult}</list_code_definition_names>\n`
 						}
-						xmlInfo += `<notice>Showing only ${maxReadFileLine} of ${totalLines} total lines. Use line_range if you need to read more lines</notice>\n`
+						xmlInfo += `<notice>Showing only ${maxReadFileLine} of ${totalLines} total lines. Use line_range if you need to read more lines. Read the specified line number range to learn more details you want to know</notice>\n`
 						updateFileResult(relPath, {
 							xmlContent: `<file><path>${relPath}</path>\n${xmlInfo}</file>`,
 						})
diff --git a/src/core/tools/searchFilesTool.ts b/src/core/tools/searchFilesTool.ts
index b6ee97f8..2504e146 100644
--- a/src/core/tools/searchFilesTool.ts
+++ b/src/core/tools/searchFilesTool.ts
@@ -5,7 +5,7 @@ import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } f
 import { ClineSayTool } from "../../shared/ExtensionMessage"
 import { getReadablePath } from "../../utils/path"
 import { isPathOutsideWorkspace } from "../../utils/pathUtils"
-import { regexSearchFiles } from "../../services/ripgrep"
+import { regexSearchFiles, OutputMode } from "../../services/ripgrep"
 
 export async function searchFilesTool(
 	cline: Task,
@@ -18,6 +18,7 @@ export async function searchFilesTool(
 	const relDirPath: string | undefined = block.params.path
 	const regex: string | undefined = block.params.regex
 	const filePattern: string | undefined = block.params.file_pattern
+	const outputMode: string | undefined = block.params.output_mode
 
 	const absolutePath = relDirPath ? path.resolve(cline.cwd, relDirPath) : cline.cwd
 	const isOutsideWorkspace = isPathOutsideWorkspace(absolutePath)
@@ -52,12 +53,22 @@ export async function searchFilesTool(
 
 			cline.consecutiveMistakeCount = 0
 
+			// Validate and set output mode
+			let validatedOutputMode: OutputMode = "content" // default
+			if (outputMode) {
+				const cleanedMode = removeClosingTag("output_mode", outputMode)
+				if (cleanedMode === "content" || cleanedMode === "files_with_matches") {
+					validatedOutputMode = cleanedMode as OutputMode
+				}
+			}
+
 			const results = await regexSearchFiles(
 				cline.cwd,
 				absolutePath,
 				regex,
 				filePattern,
 				cline.rooIgnoreController,
+				validatedOutputMode,
 			)
 
 			const completeMessage = JSON.stringify({ ...sharedMessageProps, content: results } satisfies ClineSayTool)
diff --git a/src/core/tools/useMcpToolTool.ts b/src/core/tools/useMcpToolTool.ts
index 30dff5ce..1b0440fb 100644
--- a/src/core/tools/useMcpToolTool.ts
+++ b/src/core/tools/useMcpToolTool.ts
@@ -4,6 +4,7 @@ import { formatResponse } from "../prompts/responses"
 import { ClineAskUseMcpServer } from "../../shared/ExtensionMessage"
 import { McpExecutionStatus } from "@roo-code/types"
 import { t } from "../../i18n"
+import { McpToolCallResponse } from "../../shared/mcp"
 
 interface McpToolParams {
 	server_name?: string
@@ -127,7 +128,9 @@ async function executeToolAndProcessResult(
 		toolName,
 	})
 
-	const toolResult = await cline.providerRef.deref()?.getMcpHub()?.callTool(serverName, toolName, parsedArguments)
+	let toolResult: McpToolCallResponse | undefined = undefined
+	// Removed inline tools - now use dedicated tools
+	toolResult = await cline.providerRef.deref()?.getMcpHub()?.callTool(serverName, toolName, parsedArguments)
 
 	let toolResultPretty = "(No response)"
 
diff --git a/src/core/webview/ClineProvider.ts b/src/core/webview/ClineProvider.ts
index e013525e..07852903 100644
--- a/src/core/webview/ClineProvider.ts
+++ b/src/core/webview/ClineProvider.ts
@@ -572,48 +572,48 @@ export class ClineProvider
 	public async initClineWithHistoryItem(historyItem: HistoryItem & { rootTask?: Task; parentTask?: Task }) {
 		await this.removeClineFromStack()
 
-		// If the history item has a saved mode, restore it and its associated API configuration
-		if (historyItem.mode) {
-			// Validate that the mode still exists
-			const customModes = await this.customModesManager.getCustomModes()
-			const modeExists = getModeBySlug(historyItem.mode, customModes) !== undefined
-
-			if (!modeExists) {
-				// Mode no longer exists, fall back to default mode
-				this.log(
-					`Mode '${historyItem.mode}' from history no longer exists. Falling back to default mode '${defaultModeSlug}'.`,
-				)
-				historyItem.mode = defaultModeSlug
-			}
-
-			await this.updateGlobalState("mode", historyItem.mode)
-
-			// Load the saved API config for the restored mode if it exists
-			const savedConfigId = await this.providerSettingsManager.getModeConfigId(historyItem.mode)
-			const listApiConfig = await this.providerSettingsManager.listConfig()
-
-			// Update listApiConfigMeta first to ensure UI has latest data
-			await this.updateGlobalState("listApiConfigMeta", listApiConfig)
-
-			// If this mode has a saved config, use it
-			if (savedConfigId) {
-				const profile = listApiConfig.find(({ id }) => id === savedConfigId)
-
-				if (profile?.name) {
-					try {
-						await this.activateProviderProfile({ name: profile.name })
-					} catch (error) {
-						// Log the error but continue with task restoration
-						this.log(
-							`Failed to restore API configuration for mode '${historyItem.mode}': ${
-								error instanceof Error ? error.message : String(error)
-							}. Continuing with default configuration.`,
-						)
-						// The task will continue with the current/default configuration
-					}
-				}
-			}
-		}
+		// // If the history item has a saved mode, restore it and its associated API configuration
+		// if (historyItem.mode) {
+		// 	// Validate that the mode still exists
+		// 	const customModes = await this.customModesManager.getCustomModes()
+		// 	const modeExists = getModeBySlug(historyItem.mode, customModes) !== undefined
+
+		// 	if (!modeExists) {
+		// 		// Mode no longer exists, fall back to default mode
+		// 		this.log(
+		// 			`Mode '${historyItem.mode}' from history no longer exists. Falling back to default mode '${defaultModeSlug}'.`,
+		// 		)
+		// 		historyItem.mode = defaultModeSlug
+		// 	}
+
+		// 	await this.updateGlobalState("mode", historyItem.mode)
+
+		// 	// Load the saved API config for the restored mode if it exists
+		// 	const savedConfigId = await this.providerSettingsManager.getModeConfigId(historyItem.mode)
+		// 	const listApiConfig = await this.providerSettingsManager.listConfig()
+
+		// 	// Update listApiConfigMeta first to ensure UI has latest data
+		// 	await this.updateGlobalState("listApiConfigMeta", listApiConfig)
+
+		// 	// If this mode has a saved config, use it
+		// 	if (savedConfigId) {
+		// 		const profile = listApiConfig.find(({ id }) => id === savedConfigId)
+
+		// 		if (profile?.name) {
+		// 			try {
+		// 				await this.activateProviderProfile({ name: profile.name })
+		// 			} catch (error) {
+		// 				// Log the error but continue with task restoration
+		// 				this.log(
+		// 					`Failed to restore API configuration for mode '${historyItem.mode}': ${
+		// 						error instanceof Error ? error.message : String(error)
+		// 					}. Continuing with default configuration.`,
+		// 				)
+		// 				// The task will continue with the current/default configuration
+		// 			}
+		// 		}
+		// 	}
+		// }
 
 		const {
 			apiConfiguration,
@@ -1254,7 +1254,7 @@ export class ClineProvider
 		await this.postMessageToWebview({ type: "condenseTaskContextResponse", text: taskId })
 	}
 
-	// this function deletes a task from task hidtory, and deletes it's checkpoints and delete the task folder
+	// this function deletes a task from task history, and deletes it's checkpoints and delete the task folder
 	async deleteTaskWithId(id: string) {
 		try {
 			// get the task directory full path
diff --git a/src/core/webview/webviewMessageHandler.ts b/src/core/webview/webviewMessageHandler.ts
index b1b62229..b641f1bb 100644
--- a/src/core/webview/webviewMessageHandler.ts
+++ b/src/core/webview/webviewMessageHandler.ts
@@ -50,6 +50,8 @@ import { GetModelsOptions } from "../../shared/api"
 import { generateSystemPrompt } from "./generateSystemPrompt"
 import { getCommand } from "../../utils/commands"
 
+import { saveMemory } from "./Memory-rid"
+
 const ALLOWED_VSCODE_SETTINGS = new Set(["terminal.integrated.inheritEnv"])
 
 import { MarketplaceManager, MarketplaceItemType } from "../../services/marketplace"
@@ -1336,6 +1338,23 @@ export const webviewMessageHandler = async (
 			await updateGlobalState("autoApprovalEnabled", message.bool ?? false)
 			await provider.postStateToWebview()
 			break
+		case "useTerminalCommand":
+			const tryExecuteCommand = async (retryCount = 0) => {
+				const currentCline = provider.getCurrentCline()
+				if (currentCline) {
+					currentCline.postprocess._execute_command = message.text
+				} else if (retryCount < 5) { // 最多重试5次
+					setTimeout(() => tryExecuteCommand(retryCount + 1), 100)
+				} else {
+					console.error("Failed to get current Cline instance for terminal command")
+				}
+			}
+			tryExecuteCommand()
+			break
+		case "saveMemory":
+			// 调用保存记忆函数，函数内部会发送相应的消息
+			await saveMemory(provider, message.text??"")
+			break
 		case "enhancePrompt":
 			if (message.text) {
 				try {
@@ -2042,6 +2061,9 @@ export const webviewMessageHandler = async (
 						settings.codebaseIndexMistralApiKey,
 					)
 				}
+				if (settings.codeIndexOpenAiKey !== undefined) {
+					await provider.contextProxy.storeSecret("codeIndexOpenAiKey", settings.codeIndexOpenAiKey)
+				}
 
 				// Send success response first - settings are saved regardless of validation
 				await provider.postMessageToWebview({
@@ -2194,11 +2216,10 @@ export const webviewMessageHandler = async (
 					provider.log("Cannot start indexing: No workspace folder open")
 					return
 				}
+				if (!manager.isInitialized) {
+					await manager.initialize(provider.contextProxy)
+				}
 				if (manager.isFeatureEnabled && manager.isFeatureConfigured) {
-					if (!manager.isInitialized) {
-						await manager.initialize(provider.contextProxy)
-					}
-
 					manager.startIndexing()
 				}
 			} catch (error) {
diff --git a/src/integrations/claude-code/run.ts b/src/integrations/claude-code/run.ts
index 65e32bd9..51618247 100644
--- a/src/integrations/claude-code/run.ts
+++ b/src/integrations/claude-code/run.ts
@@ -97,7 +97,7 @@ const claudeCodeTools = [
 	"Grep",
 	"LS",
 	"exit_plan_mode",
-	"Read",
+	,
 	"Edit",
 	"MultiEdit",
 	"Write",
diff --git a/src/package.json b/src/package.json
index d29a00e8..ed0e830e 100644
--- a/src/package.json
+++ b/src/package.json
@@ -3,7 +3,7 @@
 	"displayName": "%extension.displayName%",
 	"description": "%extension.description%",
 	"publisher": "RooVeterinaryInc",
-	"version": "3.25.4",
+	"version": "3.25.504",
 	"icon": "assets/icons/icon.png",
 	"galleryBanner": {
 		"color": "#617A91",
diff --git a/src/services/code-index/interfaces/vector-store.ts b/src/services/code-index/interfaces/vector-store.ts
index dde602fb..80978c35 100644
--- a/src/services/code-index/interfaces/vector-store.ts
+++ b/src/services/code-index/interfaces/vector-store.ts
@@ -33,6 +33,16 @@ export interface IVectorStore {
 		directoryPrefix?: string,
 		minScore?: number,
 		maxResults?: number,
+		query?:string,
+	): Promise<VectorStoreSearchResult[]>
+
+	/**
+	 * Searches for similar vectors
+	 * @param directoryPrefix Optional directory prefix to filter results
+	 * @returns Promise resolving to search results
+	 */
+	summary(
+		directoryPrefix?: string,
 	): Promise<VectorStoreSearchResult[]>
 
 	/**
diff --git a/src/services/code-index/manager.ts b/src/services/code-index/manager.ts
index 18e0752c..d512b3c2 100644
--- a/src/services/code-index/manager.ts
+++ b/src/services/code-index/manager.ts
@@ -9,6 +9,7 @@ import { CodeIndexServiceFactory } from "./service-factory"
 import { CodeIndexSearchService } from "./search-service"
 import { CodeIndexOrchestrator } from "./orchestrator"
 import { CacheManager } from "./cache-manager"
+import { RooIgnoreController } from "../../core/ignore/RooIgnoreController"
 import fs from "fs/promises"
 import ignore from "ignore"
 import path from "path"
@@ -28,17 +29,27 @@ export class CodeIndexManager {
 	private _searchService: CodeIndexSearchService | undefined
 	private _cacheManager: CacheManager | undefined
 
-	public static getInstance(context: vscode.ExtensionContext): CodeIndexManager | undefined {
-		// Use first workspace folder consistently
-		const workspaceFolders = vscode.workspace.workspaceFolders
-		if (!workspaceFolders || workspaceFolders.length === 0) {
-			return undefined
-		}
+	// Flag to prevent race conditions during error recovery
+	private _isRecoveringFromError = false
 
-		// Always use the first workspace folder for consistency across all indexing operations.
-		// This ensures that the same workspace context is used throughout the indexing pipeline,
-		// preventing path resolution errors in multi-workspace scenarios.
-		const workspacePath = workspaceFolders[0].uri.fsPath
+	public static getInstance(context: vscode.ExtensionContext, workspacePath?: string): CodeIndexManager | undefined {
+		// If workspacePath is not provided, try to get it from the active editor or first workspace folder
+		if (!workspacePath) {
+			const activeEditor = vscode.window.activeTextEditor
+			if (activeEditor) {
+				const workspaceFolder = vscode.workspace.getWorkspaceFolder(activeEditor.document.uri)
+				workspacePath = workspaceFolder?.uri.fsPath
+			}
+
+			if (!workspacePath) {
+				const workspaceFolders = vscode.workspace.workspaceFolders
+				if (!workspaceFolders || workspaceFolders.length === 0) {
+					return undefined
+				}
+				// Use the first workspace folder as fallback
+				workspacePath = workspaceFolders[0].uri.fsPath
+			}
+		}
 
 		if (!CodeIndexManager.instances.has(workspacePath)) {
 			CodeIndexManager.instances.set(workspacePath, new CodeIndexManager(workspacePath, context))
@@ -157,12 +168,26 @@ export class CodeIndexManager {
 
 	/**
 	 * Initiates the indexing process (initial scan and starts watcher).
+	 * Automatically recovers from error state if needed before starting.
+	 *
+	 * @important This method should NEVER be awaited as it starts a long-running background process.
+	 * The indexing will continue asynchronously and progress will be reported through events.
 	 */
-
 	public async startIndexing(): Promise<void> {
 		if (!this.isFeatureEnabled) {
 			return
 		}
+
+		// Check if we're in error state and recover if needed
+		const currentStatus = this.getCurrentStatus()
+		if (currentStatus.systemStatus === "Error") {
+			await this.recoverFromError()
+
+			// After recovery, we need to reinitialize since recoverFromError clears all services
+			// This will be handled by the caller (webviewMessageHandler) checking isInitialized
+			return
+		}
+
 		this.assertInitialized()
 		await this._orchestrator!.startIndexing()
 	}
@@ -179,6 +204,46 @@ export class CodeIndexManager {
 		}
 	}
 
+	/**
+	 * Recovers from error state by clearing the error and resetting internal state.
+	 * This allows the manager to be re-initialized after a recoverable error.
+	 *
+	 * This method clears all service instances (configManager, serviceFactory, orchestrator, searchService)
+	 * to force a complete re-initialization on the next operation. This ensures a clean slate
+	 * after recovering from errors such as network failures or configuration issues.
+	 *
+	 * @remarks
+	 * - Safe to call even when not in error state (idempotent)
+	 * - Does not restart indexing automatically - call initialize() after recovery
+	 * - Service instances will be recreated on next initialize() call
+	 * - Prevents race conditions from multiple concurrent recovery attempts
+	 */
+	public async recoverFromError(): Promise<void> {
+		// Prevent race conditions from multiple rapid recovery attempts
+		if (this._isRecoveringFromError) {
+			return
+		}
+
+		this._isRecoveringFromError = true
+		try {
+			// Clear error state
+			this._stateManager.setSystemState("Standby", "")
+		} catch (error) {
+			// Log error but continue with recovery - clearing service instances is more important
+			console.error("Failed to clear error state during recovery:", error)
+		} finally {
+			// Force re-initialization by clearing service instances
+			// This ensures a clean slate even if state update failed
+			this._configManager = undefined
+			this._serviceFactory = undefined
+			this._orchestrator = undefined
+			this._searchService = undefined
+
+			// Reset the flag after recovery is complete
+			this._isRecoveringFromError = false
+		}
+	}
+
 	/**
 	 * Cleans up the manager instance.
 	 */
@@ -205,7 +270,11 @@ export class CodeIndexManager {
 	// --- Private Helpers ---
 
 	public getCurrentStatus() {
-		return this._stateManager.getCurrentStatus()
+		const status = this._stateManager.getCurrentStatus()
+		return {
+			...status,
+			workspacePath: this.workspacePath,
+		}
 	}
 
 	public async searchIndex(query: string, directoryPrefix?: string): Promise<VectorStoreSearchResult[]> {
@@ -216,6 +285,15 @@ export class CodeIndexManager {
 		return this._searchService!.searchIndex(query, directoryPrefix)
 	}
 
+
+	public async searchSummary(directoryPrefix: string): Promise<VectorStoreSearchResult[]> {
+		if (!this.isFeatureEnabled) {
+			return []
+		}
+		this.assertInitialized()
+		return this._searchService!.searchSummary(directoryPrefix)
+	}
+
 	/**
 	 * Private helper method to recreate services with current configuration.
 	 * Used by both initialize() and handleSettingsChange().
@@ -244,6 +322,7 @@ export class CodeIndexManager {
 			return
 		}
 
+		// Create .gitignore instance
 		const ignorePath = path.join(workspacePath, ".gitignore")
 		try {
 			const content = await fs.readFile(ignorePath, "utf8")
@@ -259,11 +338,16 @@ export class CodeIndexManager {
 			})
 		}
 
+		// Create RooIgnoreController instance
+		const rooIgnoreController = new RooIgnoreController(workspacePath)
+		await rooIgnoreController.initialize()
+
 		// (Re)Create shared service instances
 		const { embedder, vectorStore, scanner, fileWatcher } = this._serviceFactory.createServices(
 			this.context,
 			this._cacheManager!,
 			ignoreInstance,
+			rooIgnoreController,
 		)
 
 		// Validate embedder configuration before proceeding