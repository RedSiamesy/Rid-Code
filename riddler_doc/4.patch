diff --git a/src/services/code-index/manager.ts b/src/services/code-index/manager.ts
index bd782da8..ebba7521 100644
--- a/src/services/code-index/manager.ts
+++ b/src/services/code-index/manager.ts
@@ -12,7 +12,13 @@ import { CacheManager } from "./cache-manager"
 import fs from "fs/promises"
 import ignore from "ignore"
 import path from "path"
-import { t } from "../../i18n"
+import { z } from "zod"
+import { Client } from "@modelcontextprotocol/sdk/client/index.js"
+import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js"
+import { CallToolResultSchema } from "@modelcontextprotocol/sdk/types.js"
+import { testEmbeddingApiAvailable, testOpenAIApiAvailable } from "./manager-test-rid"
+
+
 
 export class CodeIndexManager {
 	// --- Singleton Implementation ---
@@ -21,23 +27,19 @@ export class CodeIndexManager {
 	// Specialized class instances
 	private _configManager: CodeIndexConfigManager | undefined
 	private readonly _stateManager: CodeIndexStateManager
-	private _serviceFactory: CodeIndexServiceFactory | undefined
-	private _orchestrator: CodeIndexOrchestrator | undefined
-	private _searchService: CodeIndexSearchService | undefined
-	private _cacheManager: CacheManager | undefined
+
+	private _mcpClient : Client | undefined
+
+	private _isEnhancementEnabled: boolean = false
+	private _isEmbeddingEnabled: boolean = false
 
 	public static getInstance(context: vscode.ExtensionContext): CodeIndexManager | undefined {
-		// Use first workspace folder consistently
-		const workspaceFolders = vscode.workspace.workspaceFolders
-		if (!workspaceFolders || workspaceFolders.length === 0) {
+		const workspacePath = getWorkspacePath() // Assumes single workspace for now
+
+		if (!workspacePath) {
 			return undefined
 		}
 
-		// Always use the first workspace folder for consistency across all indexing operations.
-		// This ensures that the same workspace context is used throughout the indexing pipeline,
-		// preventing path resolution errors in multi-workspace scenarios.
-		const workspacePath = workspaceFolders[0].uri.fsPath
-
 		if (!CodeIndexManager.instances.has(workspacePath)) {
 			CodeIndexManager.instances.set(workspacePath, new CodeIndexManager(workspacePath, context))
 		}
@@ -68,26 +70,15 @@ export class CodeIndexManager {
 	}
 
 	private assertInitialized() {
-		if (!this._configManager || !this._orchestrator || !this._searchService || !this._cacheManager) {
+		if (!this._configManager) {
 			throw new Error("CodeIndexManager not initialized. Call initialize() first.")
 		}
 	}
 
 	public get state(): IndexingState {
-		if (!this.isFeatureEnabled) {
-			return "Standby"
-		}
-		this.assertInitialized()
-		return this._orchestrator!.state
+		return this._stateManager.state
 	}
 
-	public get isFeatureEnabled(): boolean {
-		return this._configManager?.isFeatureEnabled ?? false
-	}
-
-	public get isFeatureConfigured(): boolean {
-		return this._configManager?.isFeatureConfigured ?? false
-	}
 
 	public get isInitialized(): boolean {
 		try {
@@ -98,6 +89,14 @@ export class CodeIndexManager {
 		}
 	}
 
+	public get isFeatureEnabled(): boolean {
+		return this._configManager?.isFeatureEnabled ?? false
+	}
+
+	public get isFeatureConfigured(): boolean {
+		return this._configManager?.isFeatureConfigured ?? false
+	}
+
 	/**
 	 * Initializes the manager with configuration and dependent services.
 	 * Must be called before using any other methods.
@@ -111,46 +110,111 @@ export class CodeIndexManager {
 		// Load configuration once to get current state and restart requirements
 		const { requiresRestart } = await this._configManager.loadConfiguration()
 
-		// 2. Check if feature is enabled
-		if (!this.isFeatureEnabled) {
-			if (this._orchestrator) {
-				this._orchestrator.stopWatcher()
-			}
-			return { requiresRestart }
-		}
+		this._stateManager.setSystemState("Indexing", "Checking configuration.")
 
-		// 3. Check if workspace is available
-		const workspacePath = getWorkspacePath()
-		if (!workspacePath) {
-			this._stateManager.setSystemState("Standby", "No workspace folder open")
-			return { requiresRestart }
-		}
+		// 2. 创建一个独立的 MCP 客户端（不依赖 McpHub）
+		// 这里以 code_context 配置为例，实际可根据需要动态生成
+		const config = this._configManager.getConfig()
+
+		// --- 三个服务可用性校验并发执行 ---
+		let enhancementPromise: Promise<boolean> = Promise.resolve(false)
+		let embeddingPromise: Promise<boolean> = Promise.resolve(false)
 
-		// 4. CacheManager Initialization
-		if (!this._cacheManager) {
-			this._cacheManager = new CacheManager(this.context, this.workspacePath)
-			await this._cacheManager.initialize()
+		if (config.enhancementOptions && config.enhancementOptions.baseUrl) {
+			enhancementPromise = testOpenAIApiAvailable({
+				apiKey: config.enhancementOptions?.apiKey || "",
+				model: config.enhancementOptions?.modelID || "",
+				baseUrl: config.enhancementOptions?.baseUrl || ""
+			})
 		}
+		if (config.embeddingOptions && config.embeddingOptions.baseUrl) {
+			embeddingPromise = testEmbeddingApiAvailable({
+				apiKey: config.embeddingOptions?.apiKey || "",
+				model: config.embeddingOptions?.modelID || "",
+				baseUrl: config.embeddingOptions?.baseUrl || ""
+			})
+		}
+
+		// 并发等待所有校验
+		const [enhancementEnabled, embeddingEnabled] = await Promise.all([
+			enhancementPromise,
+			embeddingPromise,
+		])
+		this._isEnhancementEnabled = enhancementEnabled
+		this._isEmbeddingEnabled = embeddingEnabled
+
+		this.startIndexing()
 
-		// 4. Determine if Core Services Need Recreation
-		const needsServiceRecreation = !this._serviceFactory || requiresRestart
+		return { requiresRestart }
+	}
 
-		if (needsServiceRecreation) {
-			await this._recreateServices()
+	public async _startIndexing(): Promise<void> {
+		if (!this._configManager) {
+			this._stateManager.setSystemState("Error", "Config error.")
+			return
 		}
 
-		// 5. Handle Indexing Start/Restart
-		// The enhanced vectorStore.initialize() in startIndexing() now handles dimension changes automatically
-		// by detecting incompatible collections and recreating them, so we rely on that for dimension changes
-		const shouldStartOrRestartIndexing =
-			requiresRestart ||
-			(needsServiceRecreation && (!this._orchestrator || this._orchestrator.state !== "Indexing"))
+		if (this._mcpClient !== undefined) {
+			this._stateManager.setSystemState("Indexed", `Codebase client initialized successfully. \n  ✔ Embedding service enabled.\n  ${this._isEnhancementEnabled? "✔ Enhancement service enabled.\n" : ""}`)
+			return
+		}
 
-		if (shouldStartOrRestartIndexing) {
-			this._orchestrator?.startIndexing() // This method is async, but we don't await it here
+		const config = this._configManager.getConfig()
+		const args = []
+		args.push("-m", "code_context_mcp")
+
+		if (!this._isEmbeddingEnabled) {
+			this._stateManager.setSystemState("Error", "Embedding service is not enabled.")
+		} else {
+			// 检查并创建.roo目录
+			const rooDir = path.join(this.workspacePath, ".roo")
+			try {
+				await fs.access(rooDir)
+			} catch {
+				await fs.mkdir(rooDir, { recursive: true })
+			}
+		}
+		if (config.enhancementOptions && this._isEnhancementEnabled) {
+			args.push("--is-enhancement")
+			args.push("--enhancement-key", config.enhancementOptions.apiKey || "key")
+			args.push("--enhancement-model", config.enhancementOptions.modelID || "qwq-32b")
+			args.push("--enhancement-url", config.enhancementOptions.baseUrl || "http://10.12.154.110:7000/v1")
+		}
+		if (config.embeddingOptions && this._isEmbeddingEnabled) {
+			args.push("--embedding-key", config.embeddingOptions.apiKey || "key")
+			args.push("--embedding-model", config.embeddingOptions.modelID || "BAAI/bge-m3")
+			args.push("--embedding-url", config.embeddingOptions.baseUrl || "http://localhost:6123/embedding/v1")
+		}
+		if (config.ragPath) {
+			args.push("--rag-path", config.ragPath)
+		}
+		if (config.codeBaseLogging) {
+			args.push("--log")
 		}
 
-		return { requiresRestart }
+		const mcpConfig = {
+			command: "python",
+			args
+		}
+		const transport = new StdioClientTransport({
+			command: mcpConfig.command,
+			args: mcpConfig.args,
+			// env: mcpConfig.env,
+			cwd: this.workspacePath,
+			stderr: "pipe",
+		})
+		try {
+			const client = new Client({ name: "CodeIndexManager", version: "0.1.0" }, { capabilities: {} })
+			// await transport.start()
+			await client.connect(transport)
+			// 你可以将 client 实例保存到 this._mcpClient 以便后续调用
+			this._mcpClient = client
+			this._stateManager.setSystemState("Indexed", `Codebase client initialized successfully. \n  ✔ Embedding service enabled.\n  ${this._isEnhancementEnabled? "✔ Enhancement service enabled.\n" : ""}`)
+		} catch (error) {
+			console.error("[CodeIndexManager] Failed to initialize MCP client:", error)
+			this._stateManager.setSystemState("Error", `Codebase client initialization failed. ${error}`)
+			// throw new Error("Failed to initialize MCP client")
+		}
 	}
 
 	/**
@@ -162,18 +226,27 @@ export class CodeIndexManager {
 			return
 		}
 		this.assertInitialized()
-		await this._orchestrator!.startIndexing()
+		if (!this.isFeatureConfigured) {
+			this._stateManager.setSystemState("Standby", "Missing configuration. Save your settings to start indexing.")
+			console.warn("[CodeIndexOrchestrator] Start rejected: Missing configuration.")
+			return
+		}
+		this._stateManager.setSystemState("Indexing", "Start Indexing...")
+		this._startIndexing()
+		// this._stateManager.setSystemState("Indexing", "Initializing services...")
 	}
 
 	/**
 	 * Stops the file watcher and potentially cleans up resources.
 	 */
 	public stopWatcher(): void {
-		if (!this.isFeatureEnabled) {
-			return
-		}
-		if (this._orchestrator) {
-			this._orchestrator.stopWatcher()
+		// if (!this.isFeatureEnabled) {
+		// 	return
+		// }
+		this._stateManager.setSystemState("Standby", "File watcher stopped.")
+		if (this._mcpClient) {
+			this._mcpClient.close() // Disconnect the MCP client
+			this._mcpClient = undefined // Clear the client reference
 		}
 	}
 
@@ -181,9 +254,7 @@ export class CodeIndexManager {
 	 * Cleans up the manager instance.
 	 */
 	public dispose(): void {
-		if (this._orchestrator) {
-			this.stopWatcher()
-		}
+		this.stopWatcher()
 		this._stateManager.dispose()
 	}
 
@@ -196,8 +267,41 @@ export class CodeIndexManager {
 			return
 		}
 		this.assertInitialized()
-		await this._orchestrator!.clearIndexData()
-		await this._cacheManager!.clearCacheFile()
+
+		if (!this._mcpClient) {
+			throw new Error("MCP client not initialized")
+		}
+
+		try {
+			const response = await this._mcpClient.request(
+				{
+					method: "tools/call",
+					params: {
+						name: "delete_index",
+					}
+				},
+				CallToolResultSchema
+			)
+
+			const results: string[] = []
+			if (response && Array.isArray(response.content)) {
+				for (const item of response.content) {
+					if (item && typeof item.text === "string") {
+						results.push(item.text)
+					}
+				}
+			}
+
+			if (response.isError) {
+				console.error("[CodeIndexManager] MCP delete_index error:" + results.join(", "))
+				throw new Error("MCP delete_index returned an error:" + results.join(", "))
+			}
+		} catch (error) {
+			console.error("[CodeIndexManager] searchSummary exception:", error)
+			throw error
+		}
+
+		await this.stopWatcher()
 	}
 
 	// --- Private Helpers ---
@@ -206,95 +310,113 @@ export class CodeIndexManager {
 		return this._stateManager.getCurrentStatus()
 	}
 
-	public async searchIndex(query: string, directoryPrefix?: string): Promise<VectorStoreSearchResult[]> {
-		if (!this.isFeatureEnabled) {
-			return []
+	public async searchIndex(query: string, directoryPrefix?: string): Promise<string[]> {
+		if (!this._mcpClient) {
+			throw new Error("MCP client not initialized")
 		}
-		this.assertInitialized()
-		return this._searchService!.searchIndex(query, directoryPrefix)
-	}
 
-	/**
-	 * Private helper method to recreate services with current configuration.
-	 * Used by both initialize() and handleSettingsChange().
-	 */
-	private async _recreateServices(): Promise<void> {
-		// Stop watcher if it exists
-		if (this._orchestrator) {
-			this.stopWatcher()
+		
+		if (!this._configManager) {
+			this._stateManager.setSystemState("Error", "Config error.")
+			throw new Error("Config error.")
 		}
-		// Clear existing services to ensure clean state
-		this._orchestrator = undefined
-		this._searchService = undefined
 
-		// (Re)Initialize service factory
-		this._serviceFactory = new CodeIndexServiceFactory(
-			this._configManager!,
-			this.workspacePath,
-			this._cacheManager!,
-		)
+		const config = this._configManager.getConfig()
+
+		
+		const params: Record<string, any> = { 
+			queries: query.split("|").map(q => q.trim()), 
+			json_format: true, 
+		}
 
-		const ignoreInstance = ignore()
-		const workspacePath = getWorkspacePath()
+		if (config.llmFilter) {
+			params.llm_filter = config.llmFilter
+		}
 
-		if (!workspacePath) {
-			this._stateManager.setSystemState("Standby", "")
-			return
+		if (directoryPrefix) {
+			params.paths = [directoryPrefix]
 		}
 
-		const ignorePath = path.join(workspacePath, ".gitignore")
+		const minScore = this._configManager.currentSearchMinScore
+		const maxResults = this._configManager.currentSearchMaxResults
+
+		params.n_results = maxResults
+		params.threshold = minScore
+
 		try {
-			const content = await fs.readFile(ignorePath, "utf8")
-			ignoreInstance.add(content)
-			ignoreInstance.add(".gitignore")
+			const response = await this._mcpClient.request(
+				{
+					method: "tools/call",
+					params: {
+						name: "search_code",
+						arguments: params
+					}
+				},
+				CallToolResultSchema
+			)
+
+			const results: string[] = []
+			if (response && Array.isArray(response.content)) {
+				for (const item of response.content) {
+					if (item && typeof item.text === "string") {
+						results.push(item.text)
+					}
+				}
+			}
+
+			if (response.isError) {
+				console.error("[CodeIndexManager] MCP search_code error:" + results.join(", "))
+				throw new Error("MCP search_code returned an error:" + results.join(", "))
+			}
+
+			return results
 		} catch (error) {
-			// Should never happen: reading file failed even though it exists
-			console.error("Unexpected error loading .gitignore:", error)
-		}
-
-		// (Re)Create shared service instances
-		const { embedder, vectorStore, scanner, fileWatcher } = this._serviceFactory.createServices(
-			this.context,
-			this._cacheManager!,
-			ignoreInstance,
-		)
-
-		// Validate embedder configuration before proceeding
-		const validationResult = await this._serviceFactory.validateEmbedder(embedder)
-		if (!validationResult.valid) {
-			const errorMessage = validationResult.error || "Embedder configuration validation failed"
-			// Always attempt translation, use original as fallback
-			let translatedMessage = t(errorMessage)
-			// If translation returns a different value (stripped namespace), use original
-			if (translatedMessage !== errorMessage && !translatedMessage.includes(":")) {
-				translatedMessage = errorMessage
+			console.error("[CodeIndexManager] searchIndex exception:", error)
+			throw error
+		}
+	}
+
+	public async searchSummary(directoryPrefix: string): Promise<string[]> {
+		if (!this._mcpClient) {
+			throw new Error("MCP client not initialized")
+		}
+
+		const params: Record<string, any> = { 
+			json_format: true, 
+			paths: [directoryPrefix],
+		}
+
+		try {
+			const response = await this._mcpClient.request(
+				{
+					method: "tools/call",
+					params: {
+						name: "get_summary",
+						arguments: params
+					}
+				},
+				CallToolResultSchema
+			)
+
+			const results: string[] = []
+			if (response && Array.isArray(response.content)) {
+				for (const item of response.content) {
+					if (item && typeof item.text === "string") {
+						results.push(item.text)
+					}
+				}
+			}
+
+			if (response.isError) {
+				console.error("[CodeIndexManager] MCP get_summary error:" + results.join(", "))
+				throw new Error("MCP get_summary returned an error:" + results.join(", "))
 			}
 
-			this._stateManager.setSystemState("Error", translatedMessage)
-			throw new Error(translatedMessage)
-		}
-
-		// (Re)Initialize orchestrator
-		this._orchestrator = new CodeIndexOrchestrator(
-			this._configManager!,
-			this._stateManager,
-			this.workspacePath,
-			this._cacheManager!,
-			vectorStore,
-			scanner,
-			fileWatcher,
-		)
-
-		// (Re)Initialize search service
-		this._searchService = new CodeIndexSearchService(
-			this._configManager!,
-			this._stateManager,
-			embedder,
-			vectorStore,
-		)
-
-		// Clear any error state after successful recreation
-		this._stateManager.setSystemState("Standby", "")
+			return results
+		} catch (error) {
+			console.error("[CodeIndexManager] searchSummary exception:", error)
+			throw error
+		}
 	}
 
 	/**
@@ -310,16 +432,15 @@ export class CodeIndexManager {
 			const isFeatureEnabled = this.isFeatureEnabled
 			const isFeatureConfigured = this.isFeatureConfigured
 
-			if (requiresRestart && isFeatureEnabled && isFeatureConfigured) {
-				try {
-					// Recreate services with new configuration
-					await this._recreateServices()
-				} catch (error) {
-					// Error state already set in _recreateServices
-					console.error("Failed to recreate services:", error)
-					// Re-throw the error so the caller knows validation failed
-					throw error
-				}
+			// If configuration changes require a restart and the manager is initialized, restart the service
+			if (requiresRestart && isFeatureEnabled && isFeatureConfigured && this.isInitialized) {
+				this.stopWatcher()
+				const contextProxy = await ContextProxy.getInstance(this.context)
+				await this.initialize(contextProxy)
+				// await this.startIndexing()
+			} else if (!isFeatureEnabled) {
+				this._stateManager.setSystemState("Standby", "File watcher stopped.")
+				this.stopWatcher()
 			}
 		}
 	}
diff --git a/src/services/search/file-search.ts b/src/services/search/file-search.ts
index a25dd406..ba70bda5 100644
--- a/src/services/search/file-search.ts
+++ b/src/services/search/file-search.ts
@@ -155,7 +155,64 @@ export async function searchWorkspaceFiles(
 			}),
 		)
 
-		return verifiedResults
+		// return verifiedResults
+		let inc: typeof allItems = []
+		const _query = query.replace(/\\/g, '/')
+		if (_query.includes("/")) {
+			inc = allItems
+				.filter((item) => {
+					const itemAbsolutePath = path.resolve(workspacePath, item.path).replace(/\\/g, '/')
+					if (!itemAbsolutePath.includes(_query)) {
+						return false
+					}
+					// const afterQuery = itemAbsolutePath.split(abs_queryPath).pop() || ""
+					// const slashCount = (afterQuery.match(/\//g) || []).length
+					// if (slashCount > 1 && !afterQuery.endsWith('/')) {
+					// 	return false
+					// }
+					return true
+				})
+				.map((item) => {
+					const fullPath = path.join(workspacePath, item.path)
+					const isDirectory = fs.lstatSync(fullPath).isDirectory()
+					return {
+						...item,
+						path: item.path.toPosix(),
+						type: isDirectory ? ("folder" as const) : ("file" as const),
+					}
+				})
+		}
+		
+		// const abs_queryPath = path.resolve(workspacePath, query).replace(/\\/g, '/')
+		// let inc: typeof allItems = []
+		// if (fs.existsSync(abs_queryPath)) {
+		// 	inc = allItems
+		// 		.filter((item) => {
+		// 			const itemAbsolutePath = path.resolve(workspacePath, item.path).replace(/\\/g, '/')
+		// 			if (!itemAbsolutePath.includes(abs_queryPath)) {
+		// 				return false
+		// 			}
+		// 			const afterQuery = itemAbsolutePath.split(abs_queryPath).pop() || ""
+		// 			const slashCount = (afterQuery.match(/\//g) || []).length
+		// 			if (slashCount > 1 && !afterQuery.endsWith('/')) {
+		// 				return false
+		// 			}
+		// 			return true
+		// 		})
+		// 		.map((item) => {
+		// 			const fullPath = path.join(workspacePath, item.path)
+		// 			const isDirectory = fs.lstatSync(fullPath).isDirectory()
+		// 			return {
+		// 				...item,
+		// 				path: item.path.toPosix(),
+		// 				type: isDirectory ? ("folder" as const) : ("file" as const),
+		// 			}
+		// 		})
+		// }
+
+		return [...inc,...verifiedResults,].filter((item) => {
+			return item.type !== "folder"
+		})
 	} catch (error) {
 		console.error("Error in searchWorkspaceFiles:", error)
 		return []
diff --git a/src/shared/ExtensionMessage.ts b/src/shared/ExtensionMessage.ts
index 953c0c10..12b1ffc6 100644
--- a/src/shared/ExtensionMessage.ts
+++ b/src/shared/ExtensionMessage.ts
@@ -60,6 +60,7 @@ export interface ExtensionMessage {
 		| "messageUpdated"
 		| "mcpServers"
 		| "enhancedPrompt"
+		| "savedMemory"
 		| "commitSearchResults"
 		| "listApiConfig"
 		| "routerModels"
diff --git a/src/shared/WebviewMessage.ts b/src/shared/WebviewMessage.ts
index fa9fb673..c4877796 100644
--- a/src/shared/WebviewMessage.ts
+++ b/src/shared/WebviewMessage.ts
@@ -106,6 +106,8 @@ export interface WebviewMessage {
 		| "updateMcpTimeout"
 		| "fuzzyMatchThreshold"
 		| "writeDelayMs"
+		| "saveMemory"
+		| "savedMemory"
 		| "enhancePrompt"
 		| "enhancedPrompt"
 		| "draggedImages"
@@ -251,6 +253,18 @@ export interface WebviewMessage {
 		codeIndexQdrantApiKey?: string
 		codebaseIndexOpenAiCompatibleApiKey?: string
 		codebaseIndexGeminiApiKey?: string
+
+		// RAG settings
+		embeddingBaseUrl?: string
+		embeddingModelID?: string
+		enhancementBaseUrl?: string
+		enhancementModelID?: string
+		embeddingApiKey?: string
+		enhancementApiKey?: string
+
+		ragPath?: string
+		llmFilter?: boolean
+		codeBaseLogging?: boolean
 	}
 }
 
diff --git a/src/shared/context-mentions.ts b/src/shared/context-mentions.ts
index 2edb99de..ed5e4074 100644
--- a/src/shared/context-mentions.ts
+++ b/src/shared/context-mentions.ts
@@ -54,7 +54,7 @@ Mention regex:
 
 */
 export const mentionRegex =
-	/(?<!\\)@((?:\/|\w+:\/\/)(?:[^\s\\]|\\ )+?|[a-f0-9]{7,40}\b|problems\b|git-changes\b|terminal\b)(?=[.,;:!?]?(?=[\s\r\n]|$))/
+	/(?<!\\)@((?:\/|\w+:\/\/)(?:[^\s\\]|\\ )+?|[a-f0-9]{7,40}\b|problems\b|codebase\b|summary\b|memory\b|summary:[^\s]+?|codebase:[^\s]+?|git-changes\b|terminal\b)(?=[.,;:!?]?(?=[\s\r\n]|$))/
 export const mentionRegexGlobal = new RegExp(mentionRegex.source, "g")
 
 export interface MentionSuggestion {
diff --git a/src/shared/getApiMetrics.ts b/src/shared/getApiMetrics.ts
index 49476fdb..308c12d4 100644
--- a/src/shared/getApiMetrics.ts
+++ b/src/shared/getApiMetrics.ts
@@ -62,6 +62,8 @@ export function getApiMetrics(messages: ClineMessage[]) {
 			}
 		} else if (message.type === "say" && message.say === "condense_context") {
 			result.totalCost += message.contextCondense?.cost ?? 0
+		} else if (message.type === "say" && message.say === "save_memory") {
+			result.totalCost += message.contextCondense?.cost ?? 0
 		}
 	})
 
@@ -80,6 +82,8 @@ export function getApiMetrics(messages: ClineMessage[]) {
 			}
 		} else if (message.type === "say" && message.say === "condense_context") {
 			result.contextTokens = message.contextCondense?.newContextTokens ?? 0
+		} else if (message.type === "say" && message.say === "save_memory") {
+			result.contextTokens = message.contextCondense?.newContextTokens ?? 0
 		}
 		if (result.contextTokens) {
 			break
diff --git a/src/shared/modes.ts b/src/shared/modes.ts
index 4666a85d..df9fe31f 100644
--- a/src/shared/modes.ts
+++ b/src/shared/modes.ts
@@ -64,7 +64,7 @@ export function getToolsForMode(groups: readonly GroupEntry[]): string[] {
 export const modes: readonly ModeConfig[] = [
 	{
 		slug: "architect",
-		name: "🏗️ Architect",
+		name: "Architect",
 		roleDefinition:
 			"You are Roo, an experienced technical leader who is inquisitive and an excellent planner. Your goal is to gather information and get context to create a detailed plan for accomplishing the user's task, which the user will review and approve before they switch into another mode to implement the solution.",
 		whenToUse:
@@ -76,7 +76,7 @@ export const modes: readonly ModeConfig[] = [
 	},
 	{
 		slug: "code",
-		name: "💻 Code",
+		name: "Code",
 		roleDefinition:
 			"You are Roo, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices.",
 		whenToUse:
@@ -86,7 +86,7 @@ export const modes: readonly ModeConfig[] = [
 	},
 	{
 		slug: "ask",
-		name: "❓ Ask",
+		name: "Ask",
 		roleDefinition:
 			"You are Roo, a knowledgeable technical assistant focused on answering questions and providing information about software development, technology, and related topics.",
 		whenToUse:
@@ -96,30 +96,30 @@ export const modes: readonly ModeConfig[] = [
 		customInstructions:
 			"You can analyze code, explain concepts, and access external resources. Always answer the user's questions thoroughly, and do not switch to implementing code unless explicitly requested by the user. Include Mermaid diagrams when they clarify your response.",
 	},
-	{
-		slug: "debug",
-		name: "🪲 Debug",
-		roleDefinition:
-			"You are Roo, an expert software debugger specializing in systematic problem diagnosis and resolution.",
-		whenToUse:
-			"Use this mode when you're troubleshooting issues, investigating errors, or diagnosing problems. Specialized in systematic debugging, adding logging, analyzing stack traces, and identifying root causes before applying fixes.",
-		description: "Diagnose and fix software issues",
-		groups: ["read", "edit", "browser", "command", "mcp"],
-		customInstructions:
-			"Reflect on 5-7 different possible sources of the problem, distill those down to 1-2 most likely sources, and then add logs to validate your assumptions. Explicitly ask the user to confirm the diagnosis before fixing the problem.",
-	},
-	{
-		slug: "orchestrator",
-		name: "🪃 Orchestrator",
-		roleDefinition:
-			"You are Roo, a strategic workflow orchestrator who coordinates complex tasks by delegating them to appropriate specialized modes. You have a comprehensive understanding of each mode's capabilities and limitations, allowing you to effectively break down complex problems into discrete tasks that can be solved by different specialists.",
-		whenToUse:
-			"Use this mode for complex, multi-step projects that require coordination across different specialties. Ideal when you need to break down large tasks into subtasks, manage workflows, or coordinate work that spans multiple domains or expertise areas.",
-		description: "Coordinate tasks across multiple modes",
-		groups: [],
-		customInstructions:
-			"Your role is to coordinate complex workflows by delegating tasks to specialized modes. As an orchestrator, you should:\n\n1. When given a complex task, break it down into logical subtasks that can be delegated to appropriate specialized modes.\n\n2. For each subtask, use the `new_task` tool to delegate. Choose the most appropriate mode for the subtask's specific goal and provide comprehensive instructions in the `message` parameter. These instructions must include:\n    *   All necessary context from the parent task or previous subtasks required to complete the work.\n    *   A clearly defined scope, specifying exactly what the subtask should accomplish.\n    *   An explicit statement that the subtask should *only* perform the work outlined in these instructions and not deviate.\n    *   An instruction for the subtask to signal completion by using the `attempt_completion` tool, providing a concise yet thorough summary of the outcome in the `result` parameter, keeping in mind that this summary will be the source of truth used to keep track of what was completed on this project.\n    *   A statement that these specific instructions supersede any conflicting general instructions the subtask's mode might have.\n\n3. Track and manage the progress of all subtasks. When a subtask is completed, analyze its results and determine the next steps.\n\n4. Help the user understand how the different subtasks fit together in the overall workflow. Provide clear reasoning about why you're delegating specific tasks to specific modes.\n\n5. When all subtasks are completed, synthesize the results and provide a comprehensive overview of what was accomplished.\n\n6. Ask clarifying questions when necessary to better understand how to break down complex tasks effectively.\n\n7. Suggest improvements to the workflow based on the results of completed subtasks.\n\nUse subtasks to maintain clarity. If a request significantly shifts focus or requires a different expertise (mode), consider creating a subtask rather than overloading the current one.",
-	},
+	// {
+	// 	slug: "debug",
+	// 	name: "🪲 Debug",
+	// 	roleDefinition:
+	// 		"You are Roo, an expert software debugger specializing in systematic problem diagnosis and resolution.",
+	// 	whenToUse:
+	// 		"Use this mode when you're troubleshooting issues, investigating errors, or diagnosing problems. Specialized in systematic debugging, adding logging, analyzing stack traces, and identifying root causes before applying fixes.",
+	// 	description: "Diagnose and fix software issues",
+	// 	groups: ["read", "edit", "browser", "command", "mcp"],
+	// 	customInstructions:
+	// 		"Reflect on 5-7 different possible sources of the problem, distill those down to 1-2 most likely sources, and then add logs to validate your assumptions. Explicitly ask the user to confirm the diagnosis before fixing the problem.",
+	// },
+	// {
+	// 	slug: "orchestrator",
+	// 	name: "🪃 Orchestrator",
+	// 	roleDefinition:
+	// 		"You are Roo, a strategic workflow orchestrator who coordinates complex tasks by delegating them to appropriate specialized modes. You have a comprehensive understanding of each mode's capabilities and limitations, allowing you to effectively break down complex problems into discrete tasks that can be solved by different specialists.",
+	// 	whenToUse:
+	// 		"Use this mode for complex, multi-step projects that require coordination across different specialties. Ideal when you need to break down large tasks into subtasks, manage workflows, or coordinate work that spans multiple domains or expertise areas.",
+	// 	description: "Coordinate tasks across multiple modes",
+	// 	groups: [],
+	// 	customInstructions:
+	// 		"Your role is to coordinate complex workflows by delegating tasks to specialized modes. As an orchestrator, you should:\n\n1. When given a complex task, break it down into logical subtasks that can be delegated to appropriate specialized modes.\n\n2. For each subtask, use the `new_task` tool to delegate. Choose the most appropriate mode for the subtask's specific goal and provide comprehensive instructions in the `message` parameter. These instructions must include:\n    *   All necessary context from the parent task or previous subtasks required to complete the work.\n    *   A clearly defined scope, specifying exactly what the subtask should accomplish.\n    *   An explicit statement that the subtask should *only* perform the work outlined in these instructions and not deviate.\n    *   An instruction for the subtask to signal completion by using the `attempt_completion` tool, providing a concise yet thorough summary of the outcome in the `result` parameter, keeping in mind that this summary will be the source of truth used to keep track of what was completed on this project.\n    *   A statement that these specific instructions supersede any conflicting general instructions the subtask's mode might have.\n\n3. Track and manage the progress of all subtasks. When a subtask is completed, analyze its results and determine the next steps.\n\n4. Help the user understand how the different subtasks fit together in the overall workflow. Provide clear reasoning about why you're delegating specific tasks to specific modes.\n\n5. When all subtasks are completed, synthesize the results and provide a comprehensive overview of what was accomplished.\n\n6. Ask clarifying questions when necessary to better understand how to break down complex tasks effectively.\n\n7. Suggest improvements to the workflow based on the results of completed subtasks.\n\nUse subtasks to maintain clarity. If a request significantly shifts focus or requires a different expertise (mode), consider creating a subtask rather than overloading the current one.",
+	// },
 ] as const
 
 // Export the default mode slug
diff --git a/src/shared/support-prompt.ts b/src/shared/support-prompt.ts
index 1767a207..45b0ea7d 100644
--- a/src/shared/support-prompt.ts
+++ b/src/shared/support-prompt.ts
@@ -48,7 +48,7 @@ const supportPromptConfigs: Record<SupportPromptType, SupportPromptConfig> = {
 	ENHANCE: {
 		template: `Generate an enhanced version of this prompt (reply with only the enhanced prompt - no conversation, explanations, lead-in, bullet points, placeholders, or surrounding quotes):
 
-\${userInput}`,
+\${userInput}\n`,
 	},
 	EXPLAIN: {
 		template: `Explain the following code from file path \${filePath}:\${startLine}-\${endLine}
@@ -61,7 +61,7 @@ const supportPromptConfigs: Record<SupportPromptType, SupportPromptConfig> = {
 Please provide a clear and concise explanation of what this code does, including:
 1. The purpose and functionality
 2. Key components and their interactions
-3. Important patterns or techniques used`,
+3. Important patterns or techniques used\n`,
 	},
 	FIX: {
 		template: `Fix any issues in the following code from file path \${filePath}:\${startLine}-\${endLine}
@@ -76,7 +76,7 @@ Please:
 1. Address all detected problems listed above (if any)
 2. Identify any other potential bugs or issues
 3. Provide corrected code
-4. Explain what was fixed and why`,
+4. Explain what was fixed and why\n`,
 	},
 	IMPROVE: {
 		template: `Improve the following code from file path \${filePath}:\${startLine}-\${endLine}
@@ -92,20 +92,20 @@ Please suggest improvements for:
 3. Best practices and patterns
 4. Error handling and edge cases
 
-Provide the improved code along with explanations for each enhancement.`,
+Provide the improved code along with explanations for each enhancement.\n`,
 	},
 	ADD_TO_CONTEXT: {
 		template: `\${filePath}:\${startLine}-\${endLine}
 \`\`\`
 \${selectedText}
-\`\`\``,
+\`\`\`\n`,
 	},
 	TERMINAL_ADD_TO_CONTEXT: {
 		template: `\${userInput}
 Terminal output:
 \`\`\`
 \${terminalContent}
-\`\`\``,
+\`\`\`\n`,
 	},
 	TERMINAL_FIX: {
 		template: `\${userInput}
@@ -117,7 +117,7 @@ Fix this terminal command:
 Please:
 1. Identify any issues in the command
 2. Provide the corrected command
-3. Explain what was fixed and why`,
+3. Explain what was fixed and why\n`,
 	},
 	TERMINAL_EXPLAIN: {
 		template: `\${userInput}
@@ -129,10 +129,10 @@ Explain this terminal command:
 Please provide:
 1. What the command does
 2. Explanation of each part/flag
-3. Expected output and behavior`,
+3. Expected output and behavior\n`,
 	},
 	NEW_TASK: {
-		template: `\${userInput}`,
+		template: `\${userInput}\n`,
 	},
 } as const
 
diff --git a/webview-ui/src/components/chat/ChatRow.tsx b/webview-ui/src/components/chat/ChatRow.tsx
index 4fd7977f..c0342645 100644
--- a/webview-ui/src/components/chat/ChatRow.tsx
+++ b/webview-ui/src/components/chat/ChatRow.tsx
@@ -40,6 +40,7 @@ import { CommandExecution } from "./CommandExecution"
 import { CommandExecutionError } from "./CommandExecutionError"
 import { AutoApprovedRequestLimitWarning } from "./AutoApprovedRequestLimitWarning"
 import { CondenseContextErrorRow, CondensingContextRow, ContextCondenseRow } from "./ContextCondenseRow"
+import { SaveMemoryErrorRow, SavingMemoryRow, SaveMemoryRow } from "./saveMemoryRow-rid"
 import CodebaseSearchResultsDisplay from "./CodebaseSearchResultsDisplay"
 
 interface ChatRowProps {
@@ -229,6 +230,20 @@ export const ChatRowContent = ({
 						style={{ color: successColor, marginBottom: "-1.5px" }}></span>,
 					<span style={{ color: successColor, fontWeight: "bold" }}>{t("chat:taskCompleted")}</span>,
 				]
+			case "user_feedback":
+				return [
+					<span
+						className="codicon codicon-account"
+						style={{ color: "var(--vscode-charts-blue)", marginBottom: "-1.5px" }}></span>,
+					<span style={{ color: "var(--vscode-charts-blue)", fontWeight: "bold" }}>{"用户反馈"}</span>,
+				]
+			case "save_memory_tag":
+				return [
+					<span
+						className="codicon codicon-save"
+						style={{ color: "var(--vscode-charts-yellow)", marginBottom: "-1.5px" }}></span>,
+					<span style={{ color: "var(--vscode-charts-yellow)", fontWeight: "bold" }}>{"记忆说明"}</span>,
+				]
 			case "api_req_retry_delayed":
 				return []
 			case "api_req_started":
@@ -1029,57 +1044,30 @@ export const ChatRowContent = ({
 					)
 				case "user_feedback":
 					return (
-						<div className="bg-vscode-editor-background border rounded-xs p-1 overflow-hidden whitespace-pre-wrap">
-							{isEditing ? (
-								<div className="flex flex-col gap-2 p-2">
-									<textarea
-										className="w-full p-2 bg-vscode-input-background text-vscode-input-foreground border border-vscode-input-border rounded-xs"
-										value={editedContent}
-										onChange={(e) => setEditedContent(e.target.value)}
-										rows={5}
-										autoFocus
-									/>
-									<div className="flex justify-end gap-2">
-										<Button variant="secondary" size="sm" onClick={handleCancelEdit}>
-											{t("chat:cancel.title")}
-										</Button>
-										<Button variant="default" size="sm" onClick={handleSaveEdit}>
-											{t("chat:save.title")}
-										</Button>
-									</div>
-								</div>
-							) : (
-								<div className="flex justify-between">
-									<div className="flex-grow px-2 py-1 wrap-anywhere">
-										<Mention text={message.text} withShadow />
-									</div>
-									<div className="flex">
-										<Button
-											variant="ghost"
-											size="icon"
-											className="shrink-0 hidden"
-											disabled={isStreaming}
-											onClick={(e) => {
-												e.stopPropagation()
-												handleEditClick()
-											}}>
-											<span className="codicon codicon-edit" />
-										</Button>
-										<Button
-											variant="ghost"
-											size="icon"
-											className="shrink-0"
-											disabled={isStreaming}
-											onClick={(e) => {
-												e.stopPropagation()
-												vscode.postMessage({ type: "deleteMessage", value: message.ts })
-											}}>
-											<span className="codicon codicon-trash" />
-										</Button>
-									</div>
+						// <div className="bg-vscode-editor-background border rounded-xs p-1 overflow-hidden whitespace-pre-wrap">
+						<div>
+							<div style={headerStyle}>
+								{icon}
+								{title}
+							</div>
+							<div className="flex justify-between">
+								<div className="flex-grow px-2 py-1 wrap-anywhere" style={{ color: "var(--vscode-charts-blue)" , paddingTop: 10 }}>
+									{/* <Mention text={message.text} withShadow /> */}
+									<Markdown markdown={message.text} partial={message.partial} />
 								</div>
-							)}
-							{!isEditing && message.images && message.images.length > 0 && (
+								<Button
+									variant="ghost"
+									size="icon"
+									className="shrink-0"
+									disabled={isStreaming}
+									onClick={(e) => {
+										e.stopPropagation()
+										vscode.postMessage({ type: "deleteMessage", value: message.ts })
+									}}>
+									<span className="codicon codicon-trash" />
+								</Button>
+							</div>
+							{message.images && message.images.length > 0 && (
 								<Thumbnails images={message.images} style={{ marginTop: "8px" }} />
 							)}
 						</div>
@@ -1132,6 +1120,25 @@ export const ChatRowContent = ({
 							checkpoint={message.checkpoint}
 						/>
 					)
+				case "save_memory":
+					if (message.partial) {
+						return <SavingMemoryRow />
+					}
+					return message.contextCondense ? <SaveMemoryRow {...message.contextCondense} /> : null
+				case "save_memory_error":
+					return <SaveMemoryErrorRow errorText={message.text} />
+				case "save_memory_tag":
+					return (<div>
+						<div style={headerStyle}>
+							{icon}
+							{title}
+						</div>
+						<div className="flex justify-between">
+							<div className="flex-grow px-2 py-1 wrap-anywhere" style={{ color: "var(--vscode-charts-yellow)" , paddingTop: 10 }}>
+								<Markdown markdown={message.text} partial={message.partial} />
+							</div>
+						</div>
+					</div>)
 				case "condense_context":
 					if (message.partial) {
 						return <CondensingContextRow />
diff --git a/webview-ui/src/components/chat/ChatTextArea.tsx b/webview-ui/src/components/chat/ChatTextArea.tsx
index ee622239..3c109157 100644
--- a/webview-ui/src/components/chat/ChatTextArea.tsx
+++ b/webview-ui/src/components/chat/ChatTextArea.tsx
@@ -45,6 +45,8 @@ interface ChatTextAreaProps {
 	mode: Mode
 	setMode: (value: Mode) => void
 	modeShortcutText: string
+	isSavingMemory: boolean
+	setIsSavingMemory: (value: boolean) => void
 }
 
 const ChatTextArea = forwardRef<HTMLTextAreaElement, ChatTextAreaProps>(
@@ -64,6 +66,8 @@ const ChatTextArea = forwardRef<HTMLTextAreaElement, ChatTextAreaProps>(
 			mode,
 			setMode,
 			modeShortcutText,
+			isSavingMemory,
+			setIsSavingMemory,
 		},
 		ref,
 	) => {
@@ -178,6 +182,23 @@ const ChatTextArea = forwardRef<HTMLTextAreaElement, ChatTextAreaProps>(
 			}
 		}, [selectedType, searchQuery])
 
+		const handleSavingMemory = useCallback(() => {
+			if (sendingDisabled) {
+				return
+			}
+
+			const trimmedInput = inputValue.trim()
+
+			if (trimmedInput) {
+				setIsSavingMemory(true)
+				vscode.postMessage({ type: "saveMemory" as const, text: trimmedInput })
+			} else {
+				setIsSavingMemory(true)
+				vscode.postMessage({ type: "saveMemory" as const, text: "" })
+			}
+			setInputValue("")
+		}, [inputValue, sendingDisabled, setInputValue])
+
 		const handleEnhancePrompt = useCallback(() => {
 			if (sendingDisabled) {
 				return
@@ -199,6 +220,9 @@ const ChatTextArea = forwardRef<HTMLTextAreaElement, ChatTextAreaProps>(
 			return [
 				{ type: ContextMenuOptionType.Problems, value: "problems" },
 				{ type: ContextMenuOptionType.Terminal, value: "terminal" },
+				{ type: ContextMenuOptionType.Codebase, value: "codebase" },
+				{ type: ContextMenuOptionType.Summary, value: "summary" },
+				{ type: ContextMenuOptionType.Memory, value: "memory" },
 				...gitCommits,
 				...openedTabs
 					.filter((tab) => tab.path)
@@ -279,6 +303,12 @@ const ChatTextArea = forwardRef<HTMLTextAreaElement, ChatTextAreaProps>(
 						insertValue = "terminal"
 					} else if (type === ContextMenuOptionType.Git) {
 						insertValue = value || ""
+					} else if (type === ContextMenuOptionType.Codebase) {
+						insertValue = "codebase"
+					} else if (type === ContextMenuOptionType.Summary) {
+						insertValue = "summary"
+					} else if (type === ContextMenuOptionType.Memory) {
+					   insertValue = "memory"
 					}
 
 					const { newValue, mentionIndex } = insertMention(
@@ -381,7 +411,7 @@ const ChatTextArea = forwardRef<HTMLTextAreaElement, ChatTextAreaProps>(
 					return
 				}
 
-				if (event.key === "Enter" && !event.shiftKey && !isComposing) {
+				if (event.key === "Enter" && !event.shiftKey && !event.ctrlKey && !isComposing) {
 					event.preventDefault()
 
 					if (!sendingDisabled) {
@@ -1174,6 +1204,36 @@ const ChatTextArea = forwardRef<HTMLTextAreaElement, ChatTextAreaProps>(
 
 					<div className={cn("flex", "items-center", "gap-0.5", "shrink-0")}>
 						<IndexingStatusBadge />
+						<StandardTooltip content={t("保留永久记忆")}>
+							<button
+								aria-label={t("保留永久记忆")}
+								disabled={sendingDisabled}
+								onClick={handleSavingMemory}
+								className={cn(
+									"relative inline-flex items-center justify-center",
+									"bg-transparent border-none p-1.5",
+									"rounded-md min-w-[28px] min-h-[28px]",
+									"text-vscode-foreground opacity-85",
+									"transition-all duration-150",
+									"hover:opacity-100 hover:bg-[rgba(255,255,255,0.03)] hover:border-[rgba(255,255,255,0.15)]",
+									"focus:outline-none focus-visible:ring-1 focus-visible:ring-vscode-focusBorder",
+									"active:bg-[rgba(255,255,255,0.1)]",
+									!sendingDisabled && "cursor-pointer",
+									sendingDisabled &&
+										"opacity-40 cursor-not-allowed grayscale-[30%] hover:bg-transparent hover:border-[rgba(255,255,255,0.08)] active:bg-transparent",
+									"ml-1",
+								)}>
+								{isSavingMemory ? (
+									<div className="w-4 h-4 animate-spin rounded-full border-2 border-current border-t-transparent" />
+								) : (
+									<div className="w-4 h-4 flex items-center justify-center">
+										<svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
+											<path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 7v10c0 2.21 1.79 4 4 4h8c2.21 0 4-1.79 4-4V7M4 7c0-2.21 1.79-4 4-4h8c2.21 0 4 1.79 4 4M4 7h16m-4 4h.01M7 11h.01" />
+										</svg>
+									</div>
+								)}
+							</button>
+						</StandardTooltip>
 						<StandardTooltip content={t("chat:addImages")}>
 							<button
 								aria-label={t("chat:addImages")}