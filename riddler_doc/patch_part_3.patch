diff --git a/src/core/prompts/tools/use-mcp-tool.ts b/src/core/prompts/tools/use-mcp-tool.ts
index ac9ef5b0..aa168ffa 100644
--- a/src/core/prompts/tools/use-mcp-tool.ts
+++ b/src/core/prompts/tools/use-mcp-tool.ts
@@ -4,6 +4,7 @@ export function getUseMcpToolDescription(args: ToolArgs): string | undefined {
 	if (!args.mcpHub) {
 		return undefined
 	}
+
 	return `## use_mcp_tool
 Description: Request to use a tool provided by a connected MCP server. Each MCP server can provide multiple tools with different capabilities. Tools have defined input schemas that specify required and optional parameters.
 Parameters:
diff --git a/src/core/task/Task.ts b/src/core/task/Task.ts
index 9d68640f..f4abc4f3 100644
--- a/src/core/task/Task.ts
+++ b/src/core/task/Task.ts
@@ -47,7 +47,7 @@ import { EXPERIMENT_IDS, experiments } from "../../shared/experiments"
 import { getModelMaxOutputTokens } from "../../shared/api"
 
 // services
-import { UrlContentFetcher } from "../../services/browser/UrlContentFetcher"
+import { UrlContentFetcher } from "../../services/browser/UrlContentFetcher-riddler"
 import { BrowserSession } from "../../services/browser/BrowserSession"
 import { McpHub } from "../../services/mcp/McpHub"
 import { McpServerManager } from "../../services/mcp/McpServerManager"
@@ -78,7 +78,7 @@ import { ClineProvider } from "../webview/ClineProvider"
 import { MultiSearchReplaceDiffStrategy } from "../diff/strategies/multi-search-replace"
 import { MultiFileSearchReplaceDiffStrategy } from "../diff/strategies/multi-file-search-replace"
 import { readApiMessages, saveApiMessages, readTaskMessages, saveTaskMessages, taskMetadata } from "../task-persistence"
-import { getEnvironmentDetails } from "../environment/getEnvironmentDetails"
+import { getEnvironmentDetails, getUserSuggestions } from "../environment/getEnvironmentDetails"
 import {
 	type CheckpointDiffOptions,
 	type CheckpointRestoreOptions,
@@ -90,9 +90,14 @@ import {
 import { processUserContentMentions } from "../mentions/processUserContentMentions"
 import { ApiMessage } from "../task-persistence/apiMessages"
 import { getMessagesSinceLastSummary, summarizeConversation } from "../condense"
+import { summarizeSubTask } from "../summarize-subtask"
 import { maybeRemoveImageBlocks } from "../../api/transform/image-cleaning"
 import { restoreTodoListForTask } from "../tools/updateTodoListTool"
 
+
+import { userExecuteCommand } from "../tools/executeCommandTool"
+
+
 const MAX_EXPONENTIAL_BACKOFF_SECONDS = 600 // 10 minutes
 
 export type TaskEvents = {
@@ -241,6 +246,7 @@ export class Task extends EventEmitter<TaskEvents> {
 	consecutiveMistakeLimit: number
 	consecutiveMistakeCountForApplyDiff: Map<string, number> = new Map()
 	toolUsage: ToolUsage = {}
+	public toolSequence: string[] = [];
 
 	// Checkpoints
 	enableCheckpoints: boolean
@@ -260,6 +266,11 @@ export class Task extends EventEmitter<TaskEvents> {
 	didAlreadyUseTool = false
 	didCompleteReadingStream = false
 
+	// Riddler
+	postprocess = {
+		_execute_command: undefined as string | undefined,
+	}
+
 	constructor({
 		provider,
 		apiConfiguration,
@@ -800,6 +811,83 @@ export class Task extends EventEmitter<TaskEvents> {
 		)
 	}
 
+	public async summarizeSubTaskContext(): Promise<string> {
+		const systemPrompt = await this.getSystemPrompt()
+
+		// Get condensing configuration
+		// Using type assertion to handle the case where Phase 1 hasn't been implemented yet
+		const state = await this.providerRef.deref()?.getState()
+		const customCondensingPrompt = state ? (state as any).customCondensingPrompt : undefined
+		const condensingApiConfigId = state ? (state as any).condensingApiConfigId : undefined
+		const listApiConfigMeta = state ? (state as any).listApiConfigMeta : undefined
+
+		// Determine API handler to use
+		let condensingApiHandler: ApiHandler | undefined
+		if (condensingApiConfigId && listApiConfigMeta && Array.isArray(listApiConfigMeta)) {
+			// Using type assertion for the id property to avoid implicit any
+			const matchingConfig = listApiConfigMeta.find((config: any) => config.id === condensingApiConfigId)
+			if (matchingConfig) {
+				const profile = await this.providerRef.deref()?.providerSettingsManager.getProfile({
+					id: condensingApiConfigId,
+				})
+				// Ensure profile and apiProvider exist before trying to build handler
+				if (profile && profile.apiProvider) {
+					condensingApiHandler = buildApiHandler(profile)
+				}
+			}
+		}
+
+		const { contextTokens: prevContextTokens } = this.getTokenUsage()
+		const {
+			messages,
+			summary,
+			cost,
+			newContextTokens = 0,
+			error,
+			inputTokens = 0,
+			outputTokens = 0,
+			cacheWriteTokens = 0,
+			cacheReadTokens = 0,
+		} = await summarizeSubTask(
+			this,
+			this.apiConversationHistory,
+			this.api, // Main API handler (fallback)
+			systemPrompt, // Default summarization prompt (fallback)
+			this.taskId,
+			prevContextTokens,
+			false, // manual trigger
+			customCondensingPrompt, // User's custom prompt
+			condensingApiHandler, // Specific handler for condensing
+		)
+		
+		const maybe_cost:number = cost > 0 ? cost :
+			calculateApiCostAnthropic(
+				this.api.getModel().info,
+				inputTokens,
+				outputTokens,
+				cacheWriteTokens,
+				cacheReadTokens,
+			)
+		// Record cost using the new cost_tracking message type
+		if (maybe_cost > 0) {
+			const contextCondense: ContextCondense = { summary, cost:maybe_cost, newContextTokens, prevContextTokens }
+			await this.say(
+				"cost_tracking",
+				undefined /* text */,
+				undefined /* images */,
+				false /* partial */,
+				undefined /* checkpoint */,
+				undefined /* progressStatus */,
+				{ isNonInteractive: true } /* options */,
+				contextCondense,
+			)
+		}
+		if (error) {
+			return ""
+		}
+		return summary
+	}
+
 	async say(
 		type: ClineSay,
 		text?: string,
@@ -1415,6 +1503,7 @@ export class Task extends EventEmitter<TaskEvents> {
 			fileContextTracker: this.fileContextTracker,
 			rooIgnoreController: this.rooIgnoreController,
 			showRooIgnoredFiles,
+			globalStoragePath: this.globalStoragePath,
 			includeDiagnosticMessages,
 			maxDiagnosticMessages,
 			maxReadFileLine,
@@ -1424,8 +1513,20 @@ export class Task extends EventEmitter<TaskEvents> {
 
 		// Add environment details as its own text block, separate from tool
 		// results.
-		const finalUserContent = [...parsedUserContent, { type: "text" as const, text: environmentDetails }]
+		let userExecuteCommandResult: string | undefined = undefined
+		if (this.postprocess._execute_command) {
+			const cmd = this.postprocess._execute_command
+			this.postprocess._execute_command = undefined
+			userExecuteCommandResult = await userExecuteCommand(this, cmd)
+		}
 
+		const finalUserContent = [
+			...parsedUserContent, 
+			...(userExecuteCommandResult !== undefined ? [{ type: "text" as const, text: `User called the command in the task above in the local terminal, and the terminal displayed the following results (the results are in the <user_execute_command_result></user_execute_command_result> tag):\n<user_execute_command_result>\n${userExecuteCommandResult}\n</user_execute_command_result>` }] : []),
+			...(this.parentTask && includeFileDetails ? [{ type: "text" as const, text: "- IMPORTANT: **SUBTASK RULES** - When you complete your tasks and finally call the \`attempt_completion\` tool for summarization, you MUST describe in more detail all the tasks you completed and the conclusions you reached." }] : []), 
+			{ type: "text" as const, text: environmentDetails },
+		]
+		
 		await this.addToApiConversationHistory({ role: "user", content: finalUserContent })
 		TelemetryService.instance.captureConversationMessage(this.taskId, "user")
 
@@ -1449,6 +1550,8 @@ export class Task extends EventEmitter<TaskEvents> {
 			let inputTokens = 0
 			let outputTokens = 0
 			let totalCost: number | undefined
+			let tps: number = 0
+			let latency: number = 0
 
 			// We can't use `api_req_finished` anymore since it's a unique case
 			// where it could come after a streaming message (i.e. in the middle
@@ -1465,6 +1568,8 @@ export class Task extends EventEmitter<TaskEvents> {
 					tokensOut: outputTokens,
 					cacheWrites: cacheWriteTokens,
 					cacheReads: cacheReadTokens,
+					tps: tps ?? 0, // tokens per second
+					latency: latency ?? 0, // latency in milliseconds
 					cost:
 						totalCost ??
 						calculateApiCostAnthropic(
@@ -1561,6 +1666,8 @@ export class Task extends EventEmitter<TaskEvents> {
 							outputTokens += chunk.outputTokens
 							cacheWriteTokens += chunk.cacheWriteTokens ?? 0
 							cacheReadTokens += chunk.cacheReadTokens ?? 0
+							latency += chunk.latency ?? 0
+							tps = chunk.tps ?? 0
 							totalCost = chunk.totalCost
 							break
 						case "text": {
@@ -1968,6 +2075,22 @@ export class Task extends EventEmitter<TaskEvents> {
 			({ role, content }) => ({ role, content }),
 		)
 
+		const userSuggestions = await getUserSuggestions(this)
+		
+		// 如果cleanConversationHistory最后一个对话角色是user，且是一个数组，且userSuggestions不是undefined，
+		// 则把userSuggestions加入数组的最后一个，属性是text
+		if (cleanConversationHistory.length > 0) {
+			const lastMessage = cleanConversationHistory[cleanConversationHistory.length - 1]
+			if (lastMessage.role === "user" && Array.isArray(lastMessage.content)) {
+				if (userSuggestions !== undefined) {
+					lastMessage.content.push({
+						type: "text",
+						text: `<user_suggestions>\n${userSuggestions}\nThis is just a gentle reminder - ignore if not applicable.\n</user_suggestions>`
+					})
+				}
+			}
+		}
+
 		// Check if we've reached the maximum number of auto-approved requests
 		const maxRequests = state?.allowedMaxRequests || Infinity
 
@@ -2114,7 +2237,7 @@ export class Task extends EventEmitter<TaskEvents> {
 		if (!this.toolUsage[toolName]) {
 			this.toolUsage[toolName] = { attempts: 0, failures: 0 }
 		}
-
+		this.toolSequence.push(toolName);
 		this.toolUsage[toolName].attempts++
 	}
 
@@ -2122,7 +2245,6 @@ export class Task extends EventEmitter<TaskEvents> {
 		if (!this.toolUsage[toolName]) {
 			this.toolUsage[toolName] = { attempts: 0, failures: 0 }
 		}
-
 		this.toolUsage[toolName].failures++
 
 		if (error) {
diff --git a/src/core/tools/applyDiffTool.ts b/src/core/tools/applyDiffTool.ts
index 903e3c84..b1f96ce0 100644
--- a/src/core/tools/applyDiffTool.ts
+++ b/src/core/tools/applyDiffTool.ts
@@ -212,6 +212,18 @@ export async function applyDiffToolLegacy(
 
 				// Call saveChanges to update the DiffViewProvider properties
 				await cline.diffViewProvider.saveChanges(diagnosticsEnabled, writeDelayMs)
+
+				let newContent: string | undefined = await fs.readFile(absolutePath, "utf-8")
+
+				const agentEdits = formatResponse.createPrettyPatch(absolutePath, originalContent, newContent ?? undefined)
+				const say: ClineSayTool = {
+					tool: (!fileExists) ? "newFileCreated" : "editedExistingFile",
+					path: getReadablePath(cline.cwd, relPath),
+					diff: `# agentEdits\n${agentEdits}\n`,
+				}
+	
+				// Send the user feedback
+				await cline.say("user_feedback_diff", JSON.stringify(say))
 			}
 
 			// Track file edit operation
diff --git a/src/core/tools/attemptCompletionTool.ts b/src/core/tools/attemptCompletionTool.ts
index ef788185..2d972aa0 100644
--- a/src/core/tools/attemptCompletionTool.ts
+++ b/src/core/tools/attemptCompletionTool.ts
@@ -98,9 +98,11 @@ export async function attemptCompletionTool(
 				if (!didApprove) {
 					return
 				}
+				
+				const summary = await cline.summarizeSubTaskContext()
 
 				// tell the provider to remove the current subtask and resume the previous task in the stack
-				await cline.providerRef.deref()?.finishSubTask(result)
+				await cline.providerRef.deref()?.finishSubTask(`## Result \n${result} \n\n## Summary  \n${summary}\n\n`)
 				return
 			}
 
diff --git a/src/core/tools/codebaseSearchTool.ts b/src/core/tools/codebaseSearchTool.ts
index 236b0663..18c7a64b 100644
--- a/src/core/tools/codebaseSearchTool.ts
+++ b/src/core/tools/codebaseSearchTool.ts
@@ -17,7 +17,7 @@ export async function codebaseSearchTool(
 	removeClosingTag: RemoveClosingTag,
 ) {
 	const toolName = "codebase_search"
-	const workspacePath = getWorkspacePath()
+	const workspacePath = (cline.cwd && cline.cwd.trim() !== '') ? cline.cwd : getWorkspacePath()
 
 	if (!workspacePath) {
 		// This case should ideally not happen if Cline is initialized correctly
@@ -29,6 +29,13 @@ export async function codebaseSearchTool(
 	let query: string | undefined = block.params.query
 	let directoryPrefix: string | undefined = block.params.path
 
+
+	if (query === undefined) {
+		await getSummary(cline, block, askApproval, handleError, pushToolResult, removeClosingTag)
+		return
+	}
+
+
 	query = removeClosingTag("query", query)
 
 	if (directoryPrefix) {
@@ -132,7 +139,7 @@ ${jsonResult.results
 		(result) => `File path: ${result.filePath}
 Score: ${result.score}
 Lines: ${result.startLine}-${result.endLine}
-Code Chunk: ${result.codeChunk}
+Code Chunk: \n${result.codeChunk}
 `,
 	)
 	.join("\n")}`
@@ -142,3 +149,129 @@ Code Chunk: ${result.codeChunk}
 		await handleError(toolName, error) // Use the standard error handler
 	}
 }
+
+
+
+async function getSummary(
+	cline: Task,
+	block: ToolUse,
+	askApproval: AskApproval,
+	handleError: HandleError,
+	pushToolResult: PushToolResult,
+	removeClosingTag: RemoveClosingTag
+) {
+	const toolName = "codebase_search"
+	const workspacePath = getWorkspacePath()
+
+	if (!workspacePath) {
+		// This case should ideally not happen if Cline is initialized correctly
+		await handleError(toolName, new Error("Could not determine workspace path."))
+		return
+	}
+
+	// --- Parameter Extraction and Validation ---
+	let directoryPrefix: string | undefined = block.params.path
+	
+	if (directoryPrefix) {
+		directoryPrefix = removeClosingTag("path", directoryPrefix)
+		directoryPrefix = path.normalize(directoryPrefix)
+	} else {
+		directoryPrefix = '.'
+	}
+
+	const sharedMessageProps = {
+		tool: "codebaseSearch",
+		query: "（获取摘要）",
+		path: directoryPrefix,
+		isOutsideWorkspace: false,
+	}
+
+	if (block.partial) {
+		await cline.ask("tool", JSON.stringify(sharedMessageProps), block.partial).catch(() => {})
+		return
+	}
+
+	// if (!query) {
+	// 	cline.consecutiveMistakeCount++
+	// 	pushToolResult(await cline.sayAndCreateMissingParamError(toolName, "query"))
+	// 	return
+	// }
+
+	const didApprove = await askApproval("tool", JSON.stringify(sharedMessageProps))
+	if (!didApprove) {
+		pushToolResult(formatResponse.toolDenied())
+		return
+	}
+
+	cline.consecutiveMistakeCount = 0
+
+	// --- Core Logic ---
+	try {
+		const context = cline.providerRef.deref()?.context
+		if (!context) {
+			throw new Error("Extension context is not available.")
+		}
+
+		const manager = CodeIndexManager.getInstance(context)
+
+		if (!manager) {
+			throw new Error("CodeIndexManager is not available.")
+		}
+
+		if (!manager.isFeatureEnabled) {
+			throw new Error("Code Indexing is disabled in the settings.")
+		}
+		if (!manager.isFeatureConfigured) {
+			throw new Error("Code Indexing is not configured (Missing OpenAI Key or Qdrant URL).")
+		}
+
+		const summaryResults: VectorStoreSearchResult[] = await manager.searchSummary(directoryPrefix ?? "")
+
+		// 3. Format and push results
+		if (!summaryResults || summaryResults.length === 0) {
+			pushToolResult(`No summary found in path: "${directoryPrefix}"`) // Use simple string for no results
+			return
+		}
+
+		const jsonResult = {
+			query: "（获取摘要）",
+			results: [],
+		} as {
+			query: string
+			results: Array<{
+				filePath: string
+				score: number
+				startLine: number
+				endLine: number
+				codeChunk: string
+			}>
+		}
+
+		summaryResults.forEach((result) => {
+			if (!result.payload) return
+			if (!("filePath" in result.payload)) return
+
+			const relativePath = vscode.workspace.asRelativePath(result.payload.filePath, false)
+
+			jsonResult.results.push({
+				filePath: relativePath,
+				score: result.score,
+				startLine: result.payload.startLine,
+				endLine: result.payload.endLine,
+				codeChunk: result.payload.codeChunk.trim(),
+			})
+		})
+
+
+		// Send results to UI
+		const payload = { tool: "codebaseSearch", content: jsonResult }
+		await cline.say("codebase_search_result", JSON.stringify(payload))
+
+		// Push results to AI
+		const output = `# Codebase summary in ${directoryPrefix}:\n\n${jsonResult.results.map(result => `## File: ${result.filePath}\n${result.codeChunk}`).join("\n\n")}`
+
+		pushToolResult(output)
+	} catch (error: any) {
+		await handleError(toolName, error) // Use the standard error handler
+	}
+}
\ No newline at end of file
diff --git a/src/core/tools/executeCommandTool.ts b/src/core/tools/executeCommandTool.ts
index c346526a..95c80e6a 100644
--- a/src/core/tools/executeCommandTool.ts
+++ b/src/core/tools/executeCommandTool.ts
@@ -362,3 +362,124 @@ export async function executeCommand(
 		]
 	}
 }
+
+
+
+
+export async function userExecuteCommand(
+	task: Task,
+	cmd: string,
+): Promise<string> {
+	const handleError = async (action: string, error: Error) => {
+		const errorString = `Error ${action}: ${cmd}`
+
+		await task.say(
+			"error",
+			`Error ${action}:\n${cmd}`,
+		)
+
+		return errorString
+	}
+
+	const askApproval = async (
+		cmd:string
+	) => {
+		const { response } = await task.ask(
+			"command",
+			cmd,
+			false,
+			undefined,
+			true,
+		)
+
+		if (response !== "yesButtonClicked") {
+			throw new Error("loggic error")
+		}
+
+		return true
+	}
+	
+	try {
+		if (!cmd) {
+			return "Error: command is empty!"
+		}
+
+		task.consecutiveMistakeCount = 0
+
+		cmd = unescapeHtmlEntities(cmd) // Unescape HTML entities.
+
+		const didApprove = await askApproval(cmd)
+		delay(100)
+		if (!didApprove) {
+			return "Error: command rejected!"
+		}
+
+		const executionId = task.lastMessageTs?.toString() ?? Date.now().toString()
+		const provider = await task.providerRef.deref()
+		const providerState = await provider?.getState()
+
+		const {
+			terminalOutputLineLimit = 500,
+			terminalOutputCharacterLimit = DEFAULT_TERMINAL_OUTPUT_CHARACTER_LIMIT,
+			terminalShellIntegrationDisabled = false,
+		} = providerState ?? {}
+
+		// Get command execution timeout from VSCode configuration (in seconds)
+		const commandExecutionTimeoutSeconds = vscode.workspace
+			.getConfiguration(Package.name)
+			.get<number>("commandExecutionTimeout", 0)
+
+		// Get command timeout allowlist from VSCode configuration
+		const commandTimeoutAllowlist = vscode.workspace
+			.getConfiguration(Package.name)
+			.get<string[]>("commandTimeoutAllowlist", [])
+
+		// Check if command matches any prefix in the allowlist
+		const isCommandAllowlisted = commandTimeoutAllowlist.some((prefix) => cmd!.startsWith(prefix.trim()))
+
+		// Convert seconds to milliseconds for internal use, but skip timeout if command is allowlisted
+		const commandExecutionTimeout = isCommandAllowlisted ? 0 : commandExecutionTimeoutSeconds * 1000
+
+		const options: ExecuteCommandOptions = {
+			executionId,
+			command:cmd,
+			customCwd:task.cwd,
+			terminalShellIntegrationDisabled,
+			terminalOutputLineLimit,
+			terminalOutputCharacterLimit,
+			commandExecutionTimeout,
+		}
+
+		try {
+			const [rejected, result] = await executeCommand(task, options)
+
+			if (rejected) {
+				return "Error: command rejected!"
+			}
+
+			return result as string
+		} catch (error: unknown) {
+			const status: CommandExecutionStatus = { executionId, status: "fallback" }
+			provider?.postMessageToWebview({ type: "commandExecutionStatus", text: JSON.stringify(status) })
+			await task.say("shell_integration_warning")
+
+			if (error instanceof ShellIntegrationError) {
+				const [rejected, result] = await executeCommand(task, {
+					...options,
+					terminalShellIntegrationDisabled: true,
+				})
+
+				if (rejected) {
+					return "Error: command rejected!"
+				}
+
+				return result as string
+			} else {
+				return(`Command failed to execute in terminal due to a shell integration error.`)
+			}
+		}
+	} catch (error) {
+		return await handleError("executing command", error)
+	}
+}
+
diff --git a/src/core/tools/multiApplyDiffTool.ts b/src/core/tools/multiApplyDiffTool.ts
index db514d2b..c47aafe4 100644
--- a/src/core/tools/multiApplyDiffTool.ts
+++ b/src/core/tools/multiApplyDiffTool.ts
@@ -407,7 +407,7 @@ Original error: ${errorMessage}`
 			const fileExists = opResult.fileExists!
 
 			try {
-				let originalContent: string | null = await fs.readFile(absolutePath, "utf-8")
+				let originalContent: string = await fs.readFile(absolutePath, "utf-8")
 				let successCount = 0
 				let formattedError = ""
 
@@ -426,7 +426,7 @@ Original error: ${errorMessage}`
 				}
 
 				// Release the original content from memory as it's no longer needed
-				originalContent = null
+				// originalContent = null
 
 				if (!diffResult.success) {
 					cline.consecutiveMistakeCount++
@@ -611,6 +611,20 @@ ${errorDetails ? `\nTechnical details:\n${errorDetails}\n` : ""}
 					}
 				}
 
+				
+				let newContent: string | null = await fs.readFile(absolutePath, "utf-8")
+				
+				const agentEdits = formatResponse.createPrettyPatch(absolutePath, originalContent ?? "", newContent ?? undefined)
+				const say: ClineSayTool = {
+					tool: (!fileExists) ? "newFileCreated" : "editedExistingFile",
+					path: getReadablePath(cline.cwd, relPath),
+					diff: `# agentEdits\n${agentEdits}\n`,
+				}
+	
+				// Send the user feedback
+				await cline.say("user_feedback_diff", JSON.stringify(say))
+				
+
 				// Track file edit operation
 				await cline.fileContextTracker.trackFileContext(relPath, "roo_edited" as RecordSource)
 
diff --git a/src/core/tools/newTaskTool.ts b/src/core/tools/newTaskTool.ts
index cc56659d..1cbbe325 100644
--- a/src/core/tools/newTaskTool.ts
+++ b/src/core/tools/newTaskTool.ts
@@ -6,6 +6,9 @@ import { defaultModeSlug, getModeBySlug } from "../../shared/modes"
 import { formatResponse } from "../prompts/responses"
 import { t } from "../../i18n"
 
+import { ApiMessage } from "../task-persistence/apiMessages"
+import { getMessagesSinceLastSummary } from "../condense"
+
 export async function newTaskTool(
 	cline: Task,
 	block: ToolUse,
@@ -87,6 +90,25 @@ export async function newTaskTool(
 				return
 			}
 
+			const parentMessages:ApiMessage[] = [
+				...getMessagesSinceLastSummary(cline.apiConversationHistory), 
+				{
+					role: "user",
+					content: `现在得你，是一个由主要智能体创建的子智能体，用于完成父任务中的一个子任务。` +
+						`在此之前的对话都是主要智能体完成父任务时，所进行的对话上下文记录`,
+					ts: Date.now(),
+				},
+				{
+					role: "assistant",
+					content: `那么作为一个子智能体，我当前的任务是什么呢？`,
+					ts: Date.now(),
+				}
+			]
+			// 将父任务的对话上下文传递给子任务
+			if (cline.apiConversationHistory && cline.apiConversationHistory.length > 0) {
+				await newCline.overwriteApiConversationHistory(parentMessages)
+			}
+
 			// Now switch the newly created task to the desired mode
 			await provider.handleModeSwitch(mode)
 
diff --git a/src/core/tools/readFileTool.ts b/src/core/tools/readFileTool.ts
index 01427f4d..4b583791 100644
--- a/src/core/tools/readFileTool.ts
+++ b/src/core/tools/readFileTool.ts
@@ -578,7 +578,7 @@ export async function readFileTool(
 						if (defResult) {
 							xmlInfo += `<list_code_definition_names>${defResult}</list_code_definition_names>\n`
 						}
-						xmlInfo += `<notice>Showing only ${maxReadFileLine} of ${totalLines} total lines. Use line_range if you need to read more lines</notice>\n`
+						xmlInfo += `<notice>Showing only ${maxReadFileLine} of ${totalLines} total lines. Use line_range if you need to read more lines. Read the specified line number range to learn more details you want to know</notice>\n`
 						updateFileResult(relPath, {
 							xmlContent: `<file><path>${relPath}</path>\n${xmlInfo}</file>`,
 						})
diff --git a/src/core/tools/searchFilesTool.ts b/src/core/tools/searchFilesTool.ts
index b6ee97f8..2504e146 100644
--- a/src/core/tools/searchFilesTool.ts
+++ b/src/core/tools/searchFilesTool.ts
@@ -5,7 +5,7 @@ import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } f
 import { ClineSayTool } from "../../shared/ExtensionMessage"
 import { getReadablePath } from "../../utils/path"
 import { isPathOutsideWorkspace } from "../../utils/pathUtils"
-import { regexSearchFiles } from "../../services/ripgrep"
+import { regexSearchFiles, OutputMode } from "../../services/ripgrep"
 
 export async function searchFilesTool(
 	cline: Task,
@@ -18,6 +18,7 @@ export async function searchFilesTool(
 	const relDirPath: string | undefined = block.params.path
 	const regex: string | undefined = block.params.regex
 	const filePattern: string | undefined = block.params.file_pattern
+	const outputMode: string | undefined = block.params.output_mode
 
 	const absolutePath = relDirPath ? path.resolve(cline.cwd, relDirPath) : cline.cwd
 	const isOutsideWorkspace = isPathOutsideWorkspace(absolutePath)
@@ -52,12 +53,22 @@ export async function searchFilesTool(
 
 			cline.consecutiveMistakeCount = 0
 
+			// Validate and set output mode
+			let validatedOutputMode: OutputMode = "content" // default
+			if (outputMode) {
+				const cleanedMode = removeClosingTag("output_mode", outputMode)
+				if (cleanedMode === "content" || cleanedMode === "files_with_matches") {
+					validatedOutputMode = cleanedMode as OutputMode
+				}
+			}
+
 			const results = await regexSearchFiles(
 				cline.cwd,
 				absolutePath,
 				regex,
 				filePattern,
 				cline.rooIgnoreController,
+				validatedOutputMode,
 			)
 
 			const completeMessage = JSON.stringify({ ...sharedMessageProps, content: results } satisfies ClineSayTool)
diff --git a/src/core/tools/useMcpToolTool.ts b/src/core/tools/useMcpToolTool.ts
index 30dff5ce..1b0440fb 100644
--- a/src/core/tools/useMcpToolTool.ts
+++ b/src/core/tools/useMcpToolTool.ts
@@ -4,6 +4,7 @@ import { formatResponse } from "../prompts/responses"
 import { ClineAskUseMcpServer } from "../../shared/ExtensionMessage"
 import { McpExecutionStatus } from "@roo-code/types"
 import { t } from "../../i18n"
+import { McpToolCallResponse } from "../../shared/mcp"
 
 interface McpToolParams {
 	server_name?: string
@@ -127,7 +128,9 @@ async function executeToolAndProcessResult(
 		toolName,
 	})
 
-	const toolResult = await cline.providerRef.deref()?.getMcpHub()?.callTool(serverName, toolName, parsedArguments)
+	let toolResult: McpToolCallResponse | undefined = undefined
+	// Removed inline tools - now use dedicated tools
+	toolResult = await cline.providerRef.deref()?.getMcpHub()?.callTool(serverName, toolName, parsedArguments)
 
 	let toolResultPretty = "(No response)"
 
diff --git a/src/core/webview/ClineProvider.ts b/src/core/webview/ClineProvider.ts
index e013525e..07852903 100644
--- a/src/core/webview/ClineProvider.ts
+++ b/src/core/webview/ClineProvider.ts
@@ -572,48 +572,48 @@ export class ClineProvider
 	public async initClineWithHistoryItem(historyItem: HistoryItem & { rootTask?: Task; parentTask?: Task }) {
 		await this.removeClineFromStack()
 
-		// If the history item has a saved mode, restore it and its associated API configuration
-		if (historyItem.mode) {
-			// Validate that the mode still exists
-			const customModes = await this.customModesManager.getCustomModes()
-			const modeExists = getModeBySlug(historyItem.mode, customModes) !== undefined
-
-			if (!modeExists) {
-				// Mode no longer exists, fall back to default mode
-				this.log(
-					`Mode '${historyItem.mode}' from history no longer exists. Falling back to default mode '${defaultModeSlug}'.`,
-				)
-				historyItem.mode = defaultModeSlug
-			}
-
-			await this.updateGlobalState("mode", historyItem.mode)
-
-			// Load the saved API config for the restored mode if it exists
-			const savedConfigId = await this.providerSettingsManager.getModeConfigId(historyItem.mode)
-			const listApiConfig = await this.providerSettingsManager.listConfig()
-
-			// Update listApiConfigMeta first to ensure UI has latest data
-			await this.updateGlobalState("listApiConfigMeta", listApiConfig)
-
-			// If this mode has a saved config, use it
-			if (savedConfigId) {
-				const profile = listApiConfig.find(({ id }) => id === savedConfigId)
-
-				if (profile?.name) {
-					try {
-						await this.activateProviderProfile({ name: profile.name })
-					} catch (error) {
-						// Log the error but continue with task restoration
-						this.log(
-							`Failed to restore API configuration for mode '${historyItem.mode}': ${
-								error instanceof Error ? error.message : String(error)
-							}. Continuing with default configuration.`,
-						)
-						// The task will continue with the current/default configuration
-					}
-				}
-			}
-		}
+		// // If the history item has a saved mode, restore it and its associated API configuration
+		// if (historyItem.mode) {
+		// 	// Validate that the mode still exists
+		// 	const customModes = await this.customModesManager.getCustomModes()
+		// 	const modeExists = getModeBySlug(historyItem.mode, customModes) !== undefined
+
+		// 	if (!modeExists) {
+		// 		// Mode no longer exists, fall back to default mode
+		// 		this.log(
+		// 			`Mode '${historyItem.mode}' from history no longer exists. Falling back to default mode '${defaultModeSlug}'.`,
+		// 		)
+		// 		historyItem.mode = defaultModeSlug
+		// 	}
+
+		// 	await this.updateGlobalState("mode", historyItem.mode)
+
+		// 	// Load the saved API config for the restored mode if it exists
+		// 	const savedConfigId = await this.providerSettingsManager.getModeConfigId(historyItem.mode)
+		// 	const listApiConfig = await this.providerSettingsManager.listConfig()
+
+		// 	// Update listApiConfigMeta first to ensure UI has latest data
+		// 	await this.updateGlobalState("listApiConfigMeta", listApiConfig)
+
+		// 	// If this mode has a saved config, use it
+		// 	if (savedConfigId) {
+		// 		const profile = listApiConfig.find(({ id }) => id === savedConfigId)
+
+		// 		if (profile?.name) {
+		// 			try {
+		// 				await this.activateProviderProfile({ name: profile.name })
+		// 			} catch (error) {
+		// 				// Log the error but continue with task restoration
+		// 				this.log(
+		// 					`Failed to restore API configuration for mode '${historyItem.mode}': ${
+		// 						error instanceof Error ? error.message : String(error)
+		// 					}. Continuing with default configuration.`,
+		// 				)
+		// 				// The task will continue with the current/default configuration
+		// 			}
+		// 		}
+		// 	}
+		// }
 
 		const {
 			apiConfiguration,
@@ -1254,7 +1254,7 @@ export class ClineProvider
 		await this.postMessageToWebview({ type: "condenseTaskContextResponse", text: taskId })
 	}
 
-	// this function deletes a task from task hidtory, and deletes it's checkpoints and delete the task folder
+	// this function deletes a task from task history, and deletes it's checkpoints and delete the task folder
 	async deleteTaskWithId(id: string) {
 		try {
 			// get the task directory full path
diff --git a/src/core/webview/webviewMessageHandler.ts b/src/core/webview/webviewMessageHandler.ts
index b1b62229..b641f1bb 100644
--- a/src/core/webview/webviewMessageHandler.ts
+++ b/src/core/webview/webviewMessageHandler.ts
@@ -50,6 +50,8 @@ import { GetModelsOptions } from "../../shared/api"
 import { generateSystemPrompt } from "./generateSystemPrompt"
 import { getCommand } from "../../utils/commands"
 
+import { saveMemory } from "./Memory-rid"
+
 const ALLOWED_VSCODE_SETTINGS = new Set(["terminal.integrated.inheritEnv"])
 
 import { MarketplaceManager, MarketplaceItemType } from "../../services/marketplace"
@@ -1336,6 +1338,23 @@ export const webviewMessageHandler = async (
 			await updateGlobalState("autoApprovalEnabled", message.bool ?? false)
 			await provider.postStateToWebview()
 			break
+		case "useTerminalCommand":
+			const tryExecuteCommand = async (retryCount = 0) => {
+				const currentCline = provider.getCurrentCline()
+				if (currentCline) {
+					currentCline.postprocess._execute_command = message.text
+				} else if (retryCount < 5) { // 最多重试5次
+					setTimeout(() => tryExecuteCommand(retryCount + 1), 100)
+				} else {
+					console.error("Failed to get current Cline instance for terminal command")
+				}
+			}
+			tryExecuteCommand()
+			break
+		case "saveMemory":
+			// 调用保存记忆函数，函数内部会发送相应的消息
+			await saveMemory(provider, message.text??"")
+			break
 		case "enhancePrompt":
 			if (message.text) {
 				try {
@@ -2042,6 +2061,9 @@ export const webviewMessageHandler = async (
 						settings.codebaseIndexMistralApiKey,
 					)
 				}
+				if (settings.codeIndexOpenAiKey !== undefined) {
+					await provider.contextProxy.storeSecret("codeIndexOpenAiKey", settings.codeIndexOpenAiKey)
+				}
 
 				// Send success response first - settings are saved regardless of validation
 				await provider.postMessageToWebview({
@@ -2194,11 +2216,10 @@ export const webviewMessageHandler = async (
 					provider.log("Cannot start indexing: No workspace folder open")
 					return
 				}
+				if (!manager.isInitialized) {
+					await manager.initialize(provider.contextProxy)
+				}
 				if (manager.isFeatureEnabled && manager.isFeatureConfigured) {
-					if (!manager.isInitialized) {
-						await manager.initialize(provider.contextProxy)
-					}
-
 					manager.startIndexing()
 				}
 			} catch (error) {
diff --git a/src/integrations/claude-code/run.ts b/src/integrations/claude-code/run.ts
index 65e32bd9..51618247 100644
--- a/src/integrations/claude-code/run.ts
+++ b/src/integrations/claude-code/run.ts
@@ -97,7 +97,7 @@ const claudeCodeTools = [
 	"Grep",
 	"LS",
 	"exit_plan_mode",
-	"Read",
+	,
 	"Edit",
 	"MultiEdit",
 	"Write",
diff --git a/src/package.json b/src/package.json
index d29a00e8..ed0e830e 100644
--- a/src/package.json
+++ b/src/package.json
@@ -3,7 +3,7 @@
 	"displayName": "%extension.displayName%",
 	"description": "%extension.description%",
 	"publisher": "RooVeterinaryInc",
-	"version": "3.25.4",
+	"version": "3.25.504",
 	"icon": "assets/icons/icon.png",
 	"galleryBanner": {
 		"color": "#617A91",
diff --git a/src/services/code-index/interfaces/vector-store.ts b/src/services/code-index/interfaces/vector-store.ts
index dde602fb..80978c35 100644
--- a/src/services/code-index/interfaces/vector-store.ts
+++ b/src/services/code-index/interfaces/vector-store.ts
@@ -33,6 +33,16 @@ export interface IVectorStore {
 		directoryPrefix?: string,
 		minScore?: number,
 		maxResults?: number,
+		query?:string,
+	): Promise<VectorStoreSearchResult[]>
+
+	/**
+	 * Searches for similar vectors
+	 * @param directoryPrefix Optional directory prefix to filter results
+	 * @returns Promise resolving to search results
+	 */
+	summary(
+		directoryPrefix?: string,
 	): Promise<VectorStoreSearchResult[]>
 
 	/**
diff --git a/src/services/code-index/manager.ts b/src/services/code-index/manager.ts
index 18e0752c..d512b3c2 100644
--- a/src/services/code-index/manager.ts
+++ b/src/services/code-index/manager.ts
@@ -9,6 +9,7 @@ import { CodeIndexServiceFactory } from "./service-factory"
 import { CodeIndexSearchService } from "./search-service"
 import { CodeIndexOrchestrator } from "./orchestrator"
 import { CacheManager } from "./cache-manager"
+import { RooIgnoreController } from "../../core/ignore/RooIgnoreController"
 import fs from "fs/promises"
 import ignore from "ignore"
 import path from "path"
@@ -28,17 +29,27 @@ export class CodeIndexManager {
 	private _searchService: CodeIndexSearchService | undefined
 	private _cacheManager: CacheManager | undefined
 
-	public static getInstance(context: vscode.ExtensionContext): CodeIndexManager | undefined {
-		// Use first workspace folder consistently
-		const workspaceFolders = vscode.workspace.workspaceFolders
-		if (!workspaceFolders || workspaceFolders.length === 0) {
-			return undefined
-		}
+	// Flag to prevent race conditions during error recovery
+	private _isRecoveringFromError = false
 
-		// Always use the first workspace folder for consistency across all indexing operations.
-		// This ensures that the same workspace context is used throughout the indexing pipeline,
-		// preventing path resolution errors in multi-workspace scenarios.
-		const workspacePath = workspaceFolders[0].uri.fsPath
+	public static getInstance(context: vscode.ExtensionContext, workspacePath?: string): CodeIndexManager | undefined {
+		// If workspacePath is not provided, try to get it from the active editor or first workspace folder
+		if (!workspacePath) {
+			const activeEditor = vscode.window.activeTextEditor
+			if (activeEditor) {
+				const workspaceFolder = vscode.workspace.getWorkspaceFolder(activeEditor.document.uri)
+				workspacePath = workspaceFolder?.uri.fsPath
+			}
+
+			if (!workspacePath) {
+				const workspaceFolders = vscode.workspace.workspaceFolders
+				if (!workspaceFolders || workspaceFolders.length === 0) {
+					return undefined
+				}
+				// Use the first workspace folder as fallback
+				workspacePath = workspaceFolders[0].uri.fsPath
+			}
+		}
 
 		if (!CodeIndexManager.instances.has(workspacePath)) {
 			CodeIndexManager.instances.set(workspacePath, new CodeIndexManager(workspacePath, context))
@@ -157,12 +168,26 @@ export class CodeIndexManager {
 
 	/**
 	 * Initiates the indexing process (initial scan and starts watcher).
+	 * Automatically recovers from error state if needed before starting.
+	 *
+	 * @important This method should NEVER be awaited as it starts a long-running background process.
+	 * The indexing will continue asynchronously and progress will be reported through events.
 	 */
-
 	public async startIndexing(): Promise<void> {
 		if (!this.isFeatureEnabled) {
 			return
 		}
+
+		// Check if we're in error state and recover if needed
+		const currentStatus = this.getCurrentStatus()
+		if (currentStatus.systemStatus === "Error") {
+			await this.recoverFromError()
+
+			// After recovery, we need to reinitialize since recoverFromError clears all services
+			// This will be handled by the caller (webviewMessageHandler) checking isInitialized
+			return
+		}
+
 		this.assertInitialized()
 		await this._orchestrator!.startIndexing()
 	}
@@ -179,6 +204,46 @@ export class CodeIndexManager {
 		}
 	}
 
+	/**
+	 * Recovers from error state by clearing the error and resetting internal state.
+	 * This allows the manager to be re-initialized after a recoverable error.
+	 *
+	 * This method clears all service instances (configManager, serviceFactory, orchestrator, searchService)
+	 * to force a complete re-initialization on the next operation. This ensures a clean slate
+	 * after recovering from errors such as network failures or configuration issues.
+	 *
+	 * @remarks
+	 * - Safe to call even when not in error state (idempotent)
+	 * - Does not restart indexing automatically - call initialize() after recovery
+	 * - Service instances will be recreated on next initialize() call
+	 * - Prevents race conditions from multiple concurrent recovery attempts
+	 */
+	public async recoverFromError(): Promise<void> {
+		// Prevent race conditions from multiple rapid recovery attempts
+		if (this._isRecoveringFromError) {
+			return
+		}
+
+		this._isRecoveringFromError = true
+		try {
+			// Clear error state
+			this._stateManager.setSystemState("Standby", "")
+		} catch (error) {
+			// Log error but continue with recovery - clearing service instances is more important
+			console.error("Failed to clear error state during recovery:", error)
+		} finally {
+			// Force re-initialization by clearing service instances
+			// This ensures a clean slate even if state update failed
+			this._configManager = undefined
+			this._serviceFactory = undefined
+			this._orchestrator = undefined
+			this._searchService = undefined
+
+			// Reset the flag after recovery is complete
+			this._isRecoveringFromError = false
+		}
+	}
+
 	/**
 	 * Cleans up the manager instance.
 	 */
@@ -205,7 +270,11 @@ export class CodeIndexManager {
 	// --- Private Helpers ---
 
 	public getCurrentStatus() {
-		return this._stateManager.getCurrentStatus()
+		const status = this._stateManager.getCurrentStatus()
+		return {
+			...status,
+			workspacePath: this.workspacePath,
+		}
 	}
 
 	public async searchIndex(query: string, directoryPrefix?: string): Promise<VectorStoreSearchResult[]> {
@@ -216,6 +285,15 @@ export class CodeIndexManager {
 		return this._searchService!.searchIndex(query, directoryPrefix)
 	}
 
+
+	public async searchSummary(directoryPrefix: string): Promise<VectorStoreSearchResult[]> {
+		if (!this.isFeatureEnabled) {
+			return []
+		}
+		this.assertInitialized()
+		return this._searchService!.searchSummary(directoryPrefix)
+	}
+
 	/**
 	 * Private helper method to recreate services with current configuration.
 	 * Used by both initialize() and handleSettingsChange().
@@ -244,6 +322,7 @@ export class CodeIndexManager {
 			return
 		}
 
+		// Create .gitignore instance
 		const ignorePath = path.join(workspacePath, ".gitignore")
 		try {
 			const content = await fs.readFile(ignorePath, "utf8")
@@ -259,11 +338,16 @@ export class CodeIndexManager {
 			})
 		}
 
+		// Create RooIgnoreController instance
+		const rooIgnoreController = new RooIgnoreController(workspacePath)
+		await rooIgnoreController.initialize()
+
 		// (Re)Create shared service instances
 		const { embedder, vectorStore, scanner, fileWatcher } = this._serviceFactory.createServices(
 			this.context,
 			this._cacheManager!,
 			ignoreInstance,
+			rooIgnoreController,
 		)
 
 		// Validate embedder configuration before proceeding
diff --git a/src/services/code-index/processors/file-watcher.ts b/src/services/code-index/processors/file-watcher.ts
index 6dc1cd18..c798ec57 100644
--- a/src/services/code-index/processors/file-watcher.ts
+++ b/src/services/code-index/processors/file-watcher.ts
@@ -7,7 +7,7 @@ import {
 	INITIAL_RETRY_DELAY_MS,
 } from "../constants"
 import { createHash } from "crypto"
-import { RooIgnoreController } from "../../../core/ignore/RooIgnoreController"
+import { RooIgnoreController, CodebaseIgnoreController } from "../../../core/ignore/RooIgnoreController"
 import { v5 as uuidv5 } from "uuid"
 import { Ignore } from "ignore"
 import { scannerExtensions } from "../shared/supported-extensions"
@@ -18,8 +18,9 @@ import {
 	IVectorStore,
 	PointStruct,
 	BatchProcessingSummary,
+	ICodeParser,
 } from "../interfaces"
-import { codeParser } from "./parser"
+// import { codeParser } from "./parser"
 import { CacheManager } from "../cache-manager"
 import { generateNormalizedAbsolutePath, generateRelativeFilePath } from "../shared/get-relative-path"
 import { isPathInIgnoredDirectory } from "../../glob/ignore-utils"
@@ -34,6 +35,7 @@ export class FileWatcher implements IFileWatcher {
 	private ignoreInstance?: Ignore
 	private fileWatcher?: vscode.FileSystemWatcher
 	private ignoreController: RooIgnoreController
+	private cbIgnoreController: CodebaseIgnoreController
 	private accumulatedEvents: Map<string, { uri: vscode.Uri; type: "create" | "change" | "delete" }> = new Map()
 	private batchProcessDebounceTimer?: NodeJS.Timeout
 	private readonly BATCH_DEBOUNCE_DELAY_MS = 500
@@ -67,15 +69,16 @@ export class FileWatcher implements IFileWatcher {
 	 * @param workspacePath Path to the workspace
 	 * @param context VS Code extension context
 	 * @param embedder Optional embedder
-	 * @param vectorStore Optional vector store
+	 * @param qdrantClient Optional vector store
 	 * @param cacheManager Cache manager
 	 */
 	constructor(
 		private workspacePath: string,
 		private context: vscode.ExtensionContext,
 		private readonly cacheManager: CacheManager,
+		private readonly codeParser: ICodeParser,
 		private embedder?: IEmbedder,
-		private vectorStore?: IVectorStore,
+		private qdrantClient?: IVectorStore,
 		ignoreInstance?: Ignore,
 		ignoreController?: RooIgnoreController,
 	) {
@@ -83,6 +86,7 @@ export class FileWatcher implements IFileWatcher {
 		if (ignoreInstance) {
 			this.ignoreInstance = ignoreInstance
 		}
+		this.cbIgnoreController = new CodebaseIgnoreController(workspacePath)
 	}
 
 	/**
@@ -190,9 +194,9 @@ export class FileWatcher implements IFileWatcher {
 			}
 		}
 
-		if (allPathsToClearFromDB.size > 0 && this.vectorStore) {
+		if (allPathsToClearFromDB.size > 0 && this.qdrantClient) {
 			try {
-				await this.vectorStore.deletePointsByMultipleFilePaths(Array.from(allPathsToClearFromDB))
+				await this.qdrantClient.deletePointsByMultipleFilePaths(Array.from(allPathsToClearFromDB))
 
 				for (const path of pathsToExplicitlyDelete) {
 					this.cacheManager.deleteHash(path)
@@ -204,15 +208,20 @@ export class FileWatcher implements IFileWatcher {
 						currentFile: path,
 					})
 				}
-			} catch (error) {
-				overallBatchError = error as Error
+			} catch (error: any) {
+				const errorStatus = error?.status || error?.response?.status || error?.statusCode
+				const errorMessage = error instanceof Error ? error.message : String(error)
+
 				// Log telemetry for deletion error
 				TelemetryService.instance.captureEvent(TelemetryEventName.CODE_INDEX_ERROR, {
-					error: sanitizeErrorMessage(overallBatchError.message),
+					error: sanitizeErrorMessage(errorMessage),
 					location: "deletePointsByMultipleFilePaths",
 					errorType: "deletion_error",
+					errorStatus: errorStatus,
 				})
 
+				// Mark all paths as error
+				overallBatchError = error as Error
 				for (const path of pathsToExplicitlyDelete) {
 					batchResults.push({ path, status: "error", error: error as Error })
 					processedCountInBatch++
@@ -334,7 +343,7 @@ export class FileWatcher implements IFileWatcher {
 		batchResults: FileProcessingResult[],
 		overallBatchError?: Error,
 	): Promise<Error | undefined> {
-		if (pointsForBatchUpsert.length > 0 && this.vectorStore && !overallBatchError) {
+		if (pointsForBatchUpsert.length > 0 && this.qdrantClient && !overallBatchError) {
 			try {
 				for (let i = 0; i < pointsForBatchUpsert.length; i += BATCH_SEGMENT_THRESHOLD) {
 					const batch = pointsForBatchUpsert.slice(i, i + BATCH_SEGMENT_THRESHOLD)
@@ -343,7 +352,7 @@ export class FileWatcher implements IFileWatcher {
 
 					while (retryCount < MAX_BATCH_RETRIES) {
 						try {
-							await this.vectorStore.upsertPoints(batch)
+							await this.qdrantClient.upsertPoints(batch)
 							break
 						} catch (error) {
 							upsertError = error as Error
@@ -497,7 +506,7 @@ export class FileWatcher implements IFileWatcher {
 
 			// Check if file should be ignored
 			const relativeFilePath = generateRelativeFilePath(filePath, this.workspacePath)
-			if (
+			if (!this.cbIgnoreController.validateAccess(filePath) ||
 				!this.ignoreController.validateAccess(filePath) ||
 				(this.ignoreInstance && this.ignoreInstance.ignores(relativeFilePath))
 			) {
@@ -535,7 +544,7 @@ export class FileWatcher implements IFileWatcher {
 			}
 
 			// Parse file
-			const blocks = await codeParser.parseFile(filePath, { content, fileHash: newHash })
+			const blocks = await this.codeParser.parseFile(filePath, { content, fileHash: newHash })
 
 			// Prepare points for batch processing
 			let pointsToUpsert: PointStruct[] = []
diff --git a/src/services/code-index/processors/index.ts b/src/services/code-index/processors/index.ts
index c244d9b8..8b018f6e 100644
--- a/src/services/code-index/processors/index.ts
+++ b/src/services/code-index/processors/index.ts
@@ -1,3 +1,4 @@
 export * from "./parser"
 export * from "./scanner"
 export * from "./file-watcher"
+export * from "./parser-riddler"
diff --git a/src/services/code-index/processors/parser.ts b/src/services/code-index/processors/parser.ts
index 96d747c4..8611884a 100644
--- a/src/services/code-index/processors/parser.ts
+++ b/src/services/code-index/processors/parser.ts
@@ -5,7 +5,7 @@ import { Node } from "web-tree-sitter"
 import { LanguageParser, loadRequiredLanguageParsers } from "../../tree-sitter/languageParser"
 import { parseMarkdown } from "../../tree-sitter/markdownParser"
 import { ICodeParser, CodeBlock } from "../interfaces"
-import { scannerExtensions } from "../shared/supported-extensions"
+import { scannerExtensions, shouldUseFallbackChunking } from "../shared/supported-extensions"
 import { MAX_BLOCK_CHARS, MIN_BLOCK_CHARS, MIN_CHUNK_REMAINDER_CHARS, MAX_CHARS_TOLERANCE_FACTOR } from "../constants"
 import { TelemetryService } from "@roo-code/telemetry"
 import { TelemetryEventName } from "@roo-code/types"
@@ -101,6 +101,11 @@ export class CodeParser implements ICodeParser {
 			return this.parseMarkdownContent(filePath, content, fileHash, seenSegmentHashes)
 		}
 
+		// Check if this extension should use fallback chunking
+		if (shouldUseFallbackChunking(`.${ext}`)) {
+			return this._performFallbackChunking(filePath, content, fileHash, seenSegmentHashes)
+		}
+
 		// Check if we already have the parser loaded
 		if (!this.loadedParsers[ext]) {
 			const pendingLoad = this.pendingLoads.get(ext)
diff --git a/src/services/code-index/processors/scanner.ts b/src/services/code-index/processors/scanner.ts
index 3203076d..fc6f3779 100644
--- a/src/services/code-index/processors/scanner.ts
+++ b/src/services/code-index/processors/scanner.ts
@@ -1,6 +1,6 @@
 import { listFiles } from "../../glob/list-files"
 import { Ignore } from "ignore"
-import { RooIgnoreController } from "../../../core/ignore/RooIgnoreController"
+import { RooIgnoreController, CodebaseIgnoreController } from "../../../core/ignore/RooIgnoreController"
 import { stat } from "fs/promises"
 import * as path from "path"
 import { generateNormalizedAbsolutePath, generateRelativeFilePath } from "../shared/get-relative-path"
@@ -30,6 +30,9 @@ import { TelemetryService } from "@roo-code/telemetry"
 import { TelemetryEventName } from "@roo-code/types"
 import { sanitizeErrorMessage } from "../shared/validation-helpers"
 
+import { RiddlerEmbedder } from "../embedders/embedding-riddler"
+
+
 export class DirectoryScanner implements IDirectoryScanner {
 	constructor(
 		private readonly embedder: IEmbedder,
@@ -58,7 +61,7 @@ export class DirectoryScanner implements IDirectoryScanner {
 		const scanWorkspace = getWorkspacePathForContext(directoryPath)
 
 		// Get all files recursively (handles .gitignore automatically)
-		const [allPaths, _] = await listFiles(directoryPath, true, MAX_LIST_FILES_LIMIT_CODE_INDEX)
+		const [allPaths, _] = await listFiles(directoryPath, true, MAX_LIST_FILES_LIMIT_CODE_INDEX + 1000)
 
 		// Filter out directories (marked with trailing '/')
 		const filePaths = allPaths.filter((p) => !p.endsWith("/"))
@@ -69,10 +72,18 @@ export class DirectoryScanner implements IDirectoryScanner {
 		await ignoreController.initialize()
 
 		// Filter paths using .rooignore
-		const allowedPaths = ignoreController.filterPaths(filePaths)
+		let allowedPaths = ignoreController.filterPaths(filePaths)
+
+		// Initialize RooIgnoreController if not provided
+		const cbignoreController = new CodebaseIgnoreController(directoryPath)
+
+		await cbignoreController.initialize()
+
+		// Filter paths using .rooignore
+		allowedPaths = cbignoreController.filterPaths(allowedPaths)
 
 		// Filter by supported extensions, ignore patterns, and excluded directories
-		const supportedPaths = allowedPaths.filter((filePath) => {
+		let supportedPaths = allowedPaths.filter((filePath) => {
 			const ext = path.extname(filePath).toLowerCase()
 			const relativeFilePath = generateRelativeFilePath(filePath, scanWorkspace)
 
@@ -84,6 +95,14 @@ export class DirectoryScanner implements IDirectoryScanner {
 			return scannerExtensions.includes(ext) && !this.ignoreInstance.ignores(relativeFilePath)
 		})
 
+		const real_limit = this.embedder instanceof RiddlerEmbedder ? 800 : MAX_LIST_FILES_LIMIT_CODE_INDEX
+
+		// Sort files by most recent activity (modified, created, or accessed time)
+		// This ensures recently active files are prioritized for indexing
+		const sortedPaths = await this.sortFilesByRecentActivity(supportedPaths)
+
+		supportedPaths = sortedPaths.slice(0, real_limit)
+
 		// Initialize tracking variables
 		const processedFiles = new Set<string>()
 		let processedCount = 0
@@ -153,7 +172,7 @@ export class DirectoryScanner implements IDirectoryScanner {
 									addedBlocksFromFile = true
 
 									// Check if batch threshold is met
-									if (currentBatchBlocks.length >= BATCH_SEGMENT_THRESHOLD) {
+									if (currentBatchBlocks.length >= (this.embedder instanceof RiddlerEmbedder?1:BATCH_SEGMENT_THRESHOLD)) {
 										// Wait if we've reached the maximum pending batches
 										while (pendingBatchCount >= MAX_PENDING_BATCHES) {
 											// Wait for at least one batch to complete
@@ -281,17 +300,24 @@ export class DirectoryScanner implements IDirectoryScanner {
 					try {
 						await this.qdrantClient.deletePointsByFilePath(cachedFilePath)
 						await this.cacheManager.deleteHash(cachedFilePath)
-					} catch (error) {
+					} catch (error: any) {
+						const errorStatus = error?.status || error?.response?.status || error?.statusCode
+						const errorMessage = error instanceof Error ? error.message : String(error)
+
 						console.error(
 							`[DirectoryScanner] Failed to delete points for ${cachedFilePath} in workspace ${scanWorkspace}:`,
 							error,
 						)
+
 						TelemetryService.instance.captureEvent(TelemetryEventName.CODE_INDEX_ERROR, {
-							error: sanitizeErrorMessage(error instanceof Error ? error.message : String(error)),
+							error: sanitizeErrorMessage(errorMessage),
 							stack: error instanceof Error ? sanitizeErrorMessage(error.stack || "") : undefined,
 							location: "scanDirectory:deleteRemovedFiles",
+							errorStatus: errorStatus,
 						})
+
 						if (onError) {
+							// Report error to error handler
 							onError(
 								error instanceof Error
 									? new Error(
@@ -304,7 +330,8 @@ export class DirectoryScanner implements IDirectoryScanner {
 										),
 							)
 						}
-						// Decide if we should re-throw or just log
+						// Log error and continue processing instead of re-throwing
+						console.error(`Failed to delete points for removed file: ${cachedFilePath}`, error)
 					}
 				}
 			}
@@ -347,25 +374,30 @@ export class DirectoryScanner implements IDirectoryScanner {
 				if (uniqueFilePaths.length > 0) {
 					try {
 						await this.qdrantClient.deletePointsByMultipleFilePaths(uniqueFilePaths)
-					} catch (deleteError) {
+					} catch (deleteError: any) {
+						const errorStatus =
+							deleteError?.status || deleteError?.response?.status || deleteError?.statusCode
+						const errorMessage = deleteError instanceof Error ? deleteError.message : String(deleteError)
+
 						console.error(
 							`[DirectoryScanner] Failed to delete points for ${uniqueFilePaths.length} files before upsert in workspace ${scanWorkspace}:`,
 							deleteError,
 						)
+
 						TelemetryService.instance.captureEvent(TelemetryEventName.CODE_INDEX_ERROR, {
-							error: sanitizeErrorMessage(
-								deleteError instanceof Error ? deleteError.message : String(deleteError),
-							),
+							error: sanitizeErrorMessage(errorMessage),
 							stack:
 								deleteError instanceof Error
 									? sanitizeErrorMessage(deleteError.stack || "")
 									: undefined,
 							location: "processBatch:deletePointsByMultipleFilePaths",
 							fileCount: uniqueFilePaths.length,
+							errorStatus: errorStatus,
 						})
-						// Re-throw the error with workspace context
+
+						// Re-throw with workspace context
 						throw new Error(
-							`Failed to delete points for ${uniqueFilePaths.length} files. Workspace: ${scanWorkspace}. ${deleteError instanceof Error ? deleteError.message : String(deleteError)}`,
+							`Failed to delete points for ${uniqueFilePaths.length} files. Workspace: ${scanWorkspace}. ${errorMessage}`,
 							{ cause: deleteError },
 						)
 					}
@@ -443,4 +475,55 @@ export class DirectoryScanner implements IDirectoryScanner {
 			}
 		}
 	}
+
+	/**
+	 * Sort files by most recent activity (modified, created, or accessed time)
+	 * @param filePaths Array of file paths to sort
+	 * @returns Promise<string[]> Sorted array with most recently active files first
+	 */
+	private async sortFilesByRecentActivity(filePaths: string[]): Promise<string[]> {
+		interface FileWithTime {
+			path: string
+			mostRecentTime: number
+		}
+
+		const filesWithTimes: FileWithTime[] = []
+
+		// Get file stats for all files with concurrency control
+		const statLimiter = pLimit(50) // Limit concurrent stat operations
+		const statPromises = filePaths.map((filePath) =>
+			statLimiter(async () => {
+				try {
+					const stats = await stat(filePath)
+					
+					// Get the most recent time from modification, creation, and access times
+					const mostRecentTime = Math.max(
+						stats.mtimeMs, // Modified time
+						stats.birthtimeMs, // Creation time
+						stats.atimeMs // Access time
+					)
+
+					return {
+						path: filePath,
+						mostRecentTime
+					}
+				} catch (error) {
+					// If we can't stat the file, give it a very old timestamp so it goes to the end
+					console.warn(`Failed to stat file ${filePath}:`, error)
+					return {
+						path: filePath,
+						mostRecentTime: 0
+					}
+				}
+			})
+		)
+
+		const results = await Promise.all(statPromises)
+		filesWithTimes.push(...results)
+
+		// Sort by most recent time (descending - newest first)
+		filesWithTimes.sort((a, b) => b.mostRecentTime - a.mostRecentTime)
+
+		return filesWithTimes.map(file => file.path)
+	}
 }
diff --git a/src/services/code-index/search-service.ts b/src/services/code-index/search-service.ts
index a56f5cc6..98fcb52f 100644
--- a/src/services/code-index/search-service.ts
+++ b/src/services/code-index/search-service.ts
@@ -55,7 +55,7 @@ export class CodeIndexSearchService {
 			}
 
 			// Perform search
-			const results = await this.vectorStore.search(vector, normalizedPrefix, minScore, maxResults)
+			const results = await this.vectorStore.search(vector, normalizedPrefix, minScore, maxResults, query)
 			return results
 		} catch (error) {
 			console.error("[CodeIndexSearchService] Error during search:", error)
@@ -71,4 +71,48 @@ export class CodeIndexSearchService {
 			throw error // Re-throw the error after setting state
 		}
 	}
+
+	/**
+	 * Gets summary information from the code index.
+	 * @param directoryPrefix Optional directory path to filter results by
+	 * @returns Array of summary strings
+	 * @throws Error if the service is not properly configured or ready
+	 */
+	public async searchSummary(directoryPrefix?: string): Promise<VectorStoreSearchResult[]> {
+		if (!this.configManager.isFeatureEnabled || !this.configManager.isFeatureConfigured) {
+			throw new Error("Code index feature is disabled or not configured.")
+		}
+
+		const currentState = this.stateManager.getCurrentStatus().systemStatus
+		if (currentState !== "Indexed" && currentState !== "Indexing") {
+			// Allow summary during Indexing too
+			throw new Error(`Code index is not ready for summary. Current state: ${currentState}`)
+		}
+
+		try {
+			// Handle directory prefix
+			let normalizedPrefix: string | undefined = undefined
+			if (directoryPrefix) {
+				normalizedPrefix = path.normalize(directoryPrefix)
+			}
+
+			// Perform summary request
+			const results = await this.vectorStore.summary(normalizedPrefix)
+			return results
+		} catch (error) {
+			console.error("[CodeIndexSearchService] Error during summary:", error)
+			this.stateManager.setSystemState("Error", `Summary failed: ${(error as Error).message}`)
+
+			// Capture telemetry for the error
+			TelemetryService.instance.captureEvent(TelemetryEventName.CODE_INDEX_ERROR, {
+				error: (error as Error).message,
+				stack: (error as Error).stack,
+				location: "searchSummary",
+			})
+
+			throw error // Re-throw the error after setting state
+		}
+	}
+
+
 }
diff --git a/src/services/code-index/service-factory.ts b/src/services/code-index/service-factory.ts
index 68b0f5c0..a62959e0 100644
--- a/src/services/code-index/service-factory.ts
+++ b/src/services/code-index/service-factory.ts
@@ -1,15 +1,18 @@
 import * as vscode from "vscode"
 import { OpenAiEmbedder } from "./embedders/openai"
+import { RiddlerEmbedder } from "./embedders/embedding-riddler"
 import { CodeIndexOllamaEmbedder } from "./embedders/ollama"
 import { OpenAICompatibleEmbedder } from "./embedders/openai-compatible"
 import { GeminiEmbedder } from "./embedders/gemini"
 import { MistralEmbedder } from "./embedders/mistral"
 import { EmbedderProvider, getDefaultModelId, getModelDimension } from "../../shared/embeddingModels"
 import { QdrantVectorStore } from "./vector-store/qdrant-client"
-import { codeParser, DirectoryScanner, FileWatcher } from "./processors"
+import { RiddlerVectorStore } from "./vector-store/client-riddler"
+import { codeParser, DirectoryScanner, FileWatcher, riddlerCodeParser } from "./processors"
 import { ICodeParser, IEmbedder, IFileWatcher, IVectorStore } from "./interfaces"
 import { CodeIndexConfigManager } from "./config-manager"
 import { CacheManager } from "./cache-manager"
+import { RooIgnoreController } from "../../core/ignore/RooIgnoreController"
 import { Ignore } from "ignore"
 import { t } from "../../i18n"
 import { TelemetryService } from "@roo-code/telemetry"
@@ -45,12 +48,13 @@ export class CodeIndexServiceFactory {
 			})
 		} else if (provider === "ollama") {
 			if (!config.ollamaOptions?.ollamaBaseUrl) {
-				throw new Error(t("embeddings:serviceFactory.ollamaConfigMissing"))
+				throw new Error(`创建 Codebase-Service 缺少URL配置`)
 			}
-			return new CodeIndexOllamaEmbedder({
-				...config.ollamaOptions,
-				ollamaModelId: config.modelId,
-			})
+			return new RiddlerEmbedder()
+			// return new CodeIndexOllamaEmbedder({
+			// 	...config.ollamaOptions,
+			// 	ollamaModelId: config.modelId,
+			// })
 		} else if (provider === "openai-compatible") {
 			if (!config.openAiCompatibleOptions?.baseUrl || !config.openAiCompatibleOptions?.apiKey) {
 				throw new Error(t("embeddings:serviceFactory.openAiCompatibleConfigMissing"))
@@ -112,6 +116,13 @@ export class CodeIndexServiceFactory {
 		// Use the embedding model ID from config, not the chat model IDs
 		const modelId = config.modelId ?? defaultModel
 
+		if (provider === "ollama") {
+			if (!config.ollamaOptions?.ollamaBaseUrl) {
+				throw new Error(`创建 Codebase-Service 缺少URL配置`)
+			}
+			return new RiddlerVectorStore(this.workspacePath, config.ollamaOptions?.ollamaBaseUrl, 1024, config.qdrantApiKey)
+		}
+
 		let vectorSize: number | undefined
 
 		// First try to get the model-specific dimension from profiles
@@ -160,9 +171,20 @@ export class CodeIndexServiceFactory {
 		embedder: IEmbedder,
 		vectorStore: IVectorStore,
 		cacheManager: CacheManager,
+		codeParser: ICodeParser,
 		ignoreInstance: Ignore,
+		rooIgnoreController?: RooIgnoreController,
 	): IFileWatcher {
-		return new FileWatcher(this.workspacePath, context, cacheManager, embedder, vectorStore, ignoreInstance)
+		return new FileWatcher(
+			this.workspacePath,
+			context,
+			cacheManager,
+			codeParser,
+			embedder,
+			vectorStore,
+			ignoreInstance,
+			rooIgnoreController,
+		)
 	}
 
 	/**
@@ -173,6 +195,7 @@ export class CodeIndexServiceFactory {
 		context: vscode.ExtensionContext,
 		cacheManager: CacheManager,
 		ignoreInstance: Ignore,
+		rooIgnoreController?: RooIgnoreController,
 	): {
 		embedder: IEmbedder
 		vectorStore: IVectorStore
@@ -183,12 +206,22 @@ export class CodeIndexServiceFactory {
 		if (!this.configManager.isFeatureConfigured) {
 			throw new Error(t("embeddings:serviceFactory.codeIndexingNotConfigured"))
 		}
+		const config = this.configManager.getConfig()
+		const provider = config.embedderProvider as EmbedderProvider
 
 		const embedder = this.createEmbedder()
 		const vectorStore = this.createVectorStore()
-		const parser = codeParser
+		const parser = provider !== "ollama" ? codeParser : riddlerCodeParser
 		const scanner = this.createDirectoryScanner(embedder, vectorStore, parser, ignoreInstance)
-		const fileWatcher = this.createFileWatcher(context, embedder, vectorStore, cacheManager, ignoreInstance)
+		const fileWatcher = this.createFileWatcher(
+			context,
+			embedder,
+			vectorStore,
+			cacheManager,
+			parser,
+			ignoreInstance,
+			rooIgnoreController,
+		)
 
 		return {
 			embedder,
diff --git a/src/services/code-index/shared/supported-extensions.ts b/src/services/code-index/shared/supported-extensions.ts
index a5205631..80dd7102 100644
--- a/src/services/code-index/shared/supported-extensions.ts
+++ b/src/services/code-index/shared/supported-extensions.ts
@@ -2,3 +2,33 @@ import { extensions as allExtensions } from "../../tree-sitter"
 
 // Include all extensions including markdown for the scanner
 export const scannerExtensions = allExtensions
+
+/**
+ * Extensions that should always use fallback chunking instead of tree-sitter parsing.
+ * These are typically languages that don't have a proper WASM parser available
+ * or where the parser doesn't work correctly.
+ *
+ * NOTE: Only extensions that are already in the supported extensions list can be added here.
+ * To add support for new file types, they must first be added to the tree-sitter extensions list.
+ *
+ * HOW TO ADD A NEW FALLBACK EXTENSION:
+ * 1. First ensure the extension is in src/services/tree-sitter/index.ts extensions array
+ * 2. Add the extension to the fallbackExtensions array below
+ * 3. The file will automatically use length-based chunking for indexing
+ *
+ * Note: Do NOT remove parser cases from languageParser.ts as they may be used elsewhere
+ */
+export const fallbackExtensions = [
+	".vb", // Visual Basic .NET - no dedicated WASM parser
+	".scala", // Scala - uses fallback chunking instead of Lua query workaround
+	".swift", // Swift - uses fallback chunking due to parser instability
+]
+
+/**
+ * Check if a file extension should use fallback chunking
+ * @param extension File extension (including the dot)
+ * @returns true if the extension should use fallback chunking
+ */
+export function shouldUseFallbackChunking(extension: string): boolean {
+	return fallbackExtensions.includes(extension.toLowerCase())
+}
diff --git a/src/services/code-index/vector-store/qdrant-client.ts b/src/services/code-index/vector-store/qdrant-client.ts
index 5121d65b..1a866dbe 100644
--- a/src/services/code-index/vector-store/qdrant-client.ts
+++ b/src/services/code-index/vector-store/qdrant-client.ts
@@ -7,6 +7,8 @@ import { Payload, VectorStoreSearchResult } from "../interfaces"
 import { DEFAULT_MAX_SEARCH_RESULTS, DEFAULT_SEARCH_MIN_SCORE } from "../constants"
 import { t } from "../../../i18n"
 
+import * as vscode from "vscode"
+
 /**
  * Qdrant implementation of the vector store interface
  */
@@ -76,7 +78,7 @@ export class QdrantVectorStore implements IVectorStore {
 		}
 
 		// Generate collection name from workspace path
-		const hash = createHash("sha256").update(workspacePath).digest("hex")
+		const hash = createHash("sha256").update(`${vscode.env.machineId}@${workspacePath}`).digest("hex")
 		this.vectorSize = vectorSize
 		this.collectionName = `ws-${hash.substring(0, 16)}`
 	}
@@ -370,18 +372,32 @@ export class QdrantVectorStore implements IVectorStore {
 		directoryPrefix?: string,
 		minScore?: number,
 		maxResults?: number,
+		query?:string,
 	): Promise<VectorStoreSearchResult[]> {
 		try {
 			let filter = undefined
 
 			if (directoryPrefix) {
-				const segments = directoryPrefix.split(path.sep).filter(Boolean)
-
-				filter = {
-					must: segments.map((segment, index) => ({
-						key: `pathSegments.${index}`,
-						match: { value: segment },
-					})),
+				// Check if the path represents current directory
+				const normalizedPrefix = path.posix.normalize(directoryPrefix.replace(/\\/g, "/"))
+				// Note: path.posix.normalize("") returns ".", and normalize("./") returns "./"
+				if (normalizedPrefix === "." || normalizedPrefix === "./") {
+					// Don't create a filter - search entire workspace
+					filter = undefined
+				} else {
+					// Remove leading "./" from paths like "./src" to normalize them
+					const cleanedPrefix = path.posix.normalize(
+						normalizedPrefix.startsWith("./") ? normalizedPrefix.slice(2) : normalizedPrefix,
+					)
+					const segments = cleanedPrefix.split("/").filter(Boolean)
+					if (segments.length > 0) {
+						filter = {
+							must: segments.map((segment, index) => ({
+								key: `pathSegments.${index}`,
+								match: { value: segment },
+							})),
+						}
+					}
 				}
 			}
 
@@ -423,27 +439,62 @@ export class QdrantVectorStore implements IVectorStore {
 		}
 
 		try {
+			// First check if the collection exists
+			const collectionExists = await this.collectionExists()
+			if (!collectionExists) {
+				console.warn(
+					`[QdrantVectorStore] Skipping deletion - collection "${this.collectionName}" does not exist`,
+				)
+				return
+			}
+
 			const workspaceRoot = getWorkspacePath()
-			const normalizedPaths = filePaths.map((filePath) => {
-				const absolutePath = path.resolve(workspaceRoot, filePath)
-				return path.normalize(absolutePath)
+
+			// Build filters using pathSegments to match the indexed fields
+			const filters = filePaths.map((filePath) => {
+				// IMPORTANT: Use the relative path to match what's stored in upsertPoints
+				// upsertPoints stores the relative filePath, not the absolute path
+				const relativePath = path.isAbsolute(filePath) ? path.relative(workspaceRoot, filePath) : filePath
+
+				// Normalize the relative path
+				const normalizedRelativePath = path.normalize(relativePath)
+
+				// Split the path into segments like we do in upsertPoints
+				const segments = normalizedRelativePath.split(path.sep).filter(Boolean)
+
+				// Create a filter that matches all segments of the path
+				// This ensures we only delete points that match the exact file path
+				const mustConditions = segments.map((segment, index) => ({
+					key: `pathSegments.${index}`,
+					match: { value: segment },
+				}))
+
+				return { must: mustConditions }
 			})
 
-			const filter = {
-				should: normalizedPaths.map((normalizedPath) => ({
-					key: "filePath",
-					match: {
-						value: normalizedPath,
-					},
-				})),
-			}
+			// Use 'should' to match any of the file paths (OR condition)
+			const filter = filters.length === 1 ? filters[0] : { should: filters }
 
 			await this.client.delete(this.collectionName, {
 				filter,
 				wait: true,
 			})
-		} catch (error) {
-			console.error("Failed to delete points by file paths:", error)
+		} catch (error: any) {
+			// Extract more detailed error information
+			const errorMessage = error?.message || String(error)
+			const errorStatus = error?.status || error?.response?.status || error?.statusCode
+			const errorDetails = error?.response?.data || error?.data || ""
+
+			console.error(`[QdrantVectorStore] Failed to delete points by file paths:`, {
+				error: errorMessage,
+				status: errorStatus,
+				details: errorDetails,
+				collection: this.collectionName,
+				fileCount: filePaths.length,
+				// Include first few file paths for debugging (avoid logging too many)
+				samplePaths: filePaths.slice(0, 3),
+			})
+
 			throw error
 		}
 	}
@@ -463,6 +514,12 @@ export class QdrantVectorStore implements IVectorStore {
 		}
 	}
 
+	async summary(
+		directoryPrefix?: string,
+	): Promise<VectorStoreSearchResult[]> {
+		return []
+	}
+
 	/**
 	 * Clears all points from the collection
 	 */